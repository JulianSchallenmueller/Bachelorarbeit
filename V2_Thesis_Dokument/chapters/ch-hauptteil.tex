% Bsp. eines Hauptteils

\chapter{Grundlagen}
\label{sec:grundl}

\section[Funktionsprinzip, Vorteile und Herausforderungen]{Funktionsprinzip, Vorteile und Herausforderungen des modernen Cloud Computings}

Um die Rolle von Infrastructure as Code und Terraform vollständig erläutern zu können sollte zuerst das grundlegende Funktionsprinzip und die verschiedenen Service- und Bereitstellungs-Modelle moderner Cloud Plattformen erklärt werden. Die am meisten verwendete Definition von Cloud Computing wurde vom National Institute of Standards and Technology der Vereinigten Staaten von Amerika veröffentlicht und wird im folgenden Kapitel zusammengefasst.

\subsection{Definition und Funktionsweise}

Das National Institute of Standards and Technology (NIST) der Vereinigten
Staaten von Amerika definiert Cloud Computing im Abstract der NIST SP-800-145\cite{def-cloud}
folgendermaßen:\\

\enquote{Cloud computing is a model for enabling ubiquitous, convenient, on-demand network access to a shared
pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that
can be rapidly provisioned and released with minimal management effort or service provider interaction.
This cloud model is composed of five essential characteristics, three service models, and four deployment
models.}\\

Cloud Computing beschreibt ein Modell das es ermöglicht ortsunabhängig, zweckdienlich und zeitunabhängig auf einen konfigurierbaren Pool an Computing Ressourcen (Netzwerke, Server,
 Datenspeicher, Anwendungen und Services) zuzugreifen die schnell und mit minimalem
Aufwand und minimaler notwendiger Interaktion bereitgestellt und wieder abgebaut werden können.
Dieses Cloud Modell beschreibt fünf essentielle Charakteristiken, drei Servicemodelle
und vier Bereitstellungsmodelle.\\

Weiter definiert das Dokument die fünf Charakteristiken in den folgenden Punkten:

\textbf{On-demand-self-service}: Der Nutzer kann eigenmächtig die benötigten Computing Ressourcen automatisch bereitstellen, es wird keine menschliche Interaktion benötigt.

\textbf{Broad network access}: Auf Leistungen wird über das normale Internet mit standardmäßigen
Mechanismen wie der Nutzung von Thin Clients und Fat Clients (Smartphones, Tablets,
Laptops oder Workstations) zugegriffen.

\textbf{Resource Pooling}: Die Computing Ressourcen des Anbieters werden in einem gemeinsamen Pool
für mehrere Kunden in einem Multi-Tenancy-fähigen Modell bereitgestellt, physische und
 virtuelle Ressourcen werden dynamisch zugewiesen und entsprechend der Nachfrage
kontinuierlich neu verteilt. Es wird eine empfundene Ortsunabhängigkeit hergestellt indem der Nutzer
kein genaues Wissen darüber besitzt wo sich dessen Ressourcen befinden, auf höherem
 Level wie beispielsweise dem Staat, der Region oder auch Rechenzentrum kann
der Ort vom Nutzer spezifiziert werden. Die bereitgestellten Ressourcen beinhalten
zum Beispiel Datenspeicher, Rechenleistung, Arbeitsspeicher und Netzwerkbandbreite.


\textbf{Rapid Elasticity}: Rechenkapazitäten werden dehnbar bereitgestellt und abgebaut,
 teilweise automatisch, um entsprechend der Nachfrage schnell hoch- und wieder
zurück skalieren zu können. Rechenkapazitäten erscheinen dadurch unbegrenzt und können
zu jeder Zeit und in jedem Umfang bereitgestellt werden.


\textbf{Measured Service}: Cloud Systeme kontrollieren und optimieren Ressourcennutzung
 automatisch mithilfe eines Mess-Systems dass auf einer abstrakten Ebene den
entsprechenden Service (Datenspeicher, Rechenleistung, Benutzerkonten, etc.) überwacht,
kontrolliert und Bericht erstattet um sowohl für Anbieter als auch Kunden Transparenz
herzustellen.\\

Es wird zwischen drei grundlegende Cloud Service Modellen unterschieden: Infrastructure
as a Service (IaaS), Platform as a Service (PaaS) und Software as a Service (SaaS) (Abb. 2.1).

\begin{figure}[H]

	\includegraphics[width=1.0\textwidth]{fig/aa-hauptteil/Service-Models.png}

	\caption{Die Cloud Service Modelle im Überblick\cite{svc-mod}}

	\centering

\end{figure}

\textbf{Infrastructure as a Service:} Der Nutzer hat die Fähigkeit Rechenleistung, Datenspeicher
 Netzwerke und weitere fundamentale Computing Ressourcen bereitzustellen und beliebige Software
 darauf zu betreiben, dazu können Betriebssysteme und Anwendungen gehören. Die
darunterliegende Infrastruktur wird vom Anbieter betrieben, der Nutzer kann aber
eingeschränkte Kontrolle über bestimmte Komponenten haben, dazu gehören beispielsweise
Firewalls.


\textbf{Platform as a Service:} Der Nutzer verfügt über die Fähigkeit seine eingekaufte oder
selbst erstellten Anwendungen auf der Cloud Infrastruktur zu betreiben, die notwendige
Umgebung die über Sprachen, Bibliotheken, Tools und Services verfügt wird vom Cloud Service Provider (CSP) bereitgestellt. Die darunter liegende Infrastruktur mit Netzwerken, Servern,
Betriebssystemen und Speicher wird vom CSP betrieben, der Nutzer hat die Kontrolle
über Anwendung und Konfiguration der Umgebung in der die Anwendung betrieben wird.


\textbf{Software as a Service:} Dem Nutzer wird der Zugriff auf die vom CSP in der
Cloud Infrastruktur betriebenen Softwareanwendung gewährt. Auf diese wird mithilfe
eines Thin oder Fat Client zugegriffen, dabei kümmert sich der Nutzer nicht um den
Betrieb und die Konfiguration der darunterliegenden Cloud Infrastruktur (Netzwerke, Server, Betriebssystem, Speicher) und die Anwendung selbst mit Ausnahme
eingeschränkter Nutzereinstellungen.\\

In Art der Bereitstellung eines Cloud Services werden vier grundlegende Modelle
unterschieden; es existieren Public, Private, Hybrid und Community Cloud Modelle.\\


\textbf{Private Cloud}: Die Cloud Infrastruktur wird ausschließlich für die Nutzung durch eine einzige
Organisation mit mehreren Nutzern bereitgestellt. Besitz und Betrieb liegen dabei
entweder bei der selben Organisation, einer Drittpartei oder einer Kombination beider, die Infrastruktur kann dabei On- oder Off-Premises\footnote{Hardware ist lokal vor Ort/nicht vor Ort} betrieben werden.

\textbf{Public Cloud}: Die Public Cloud steht für die Nutzung durch die allgemeine Öffentlichkeit bereit.
Die Cloud Infrastruktur befindet sich im Besitz eines Unternehmens, Bildungseinrichtung,
Regierungsorganisation oder einer Kombination aus diesen und wird auch von der selben
 Organisation On-Premises betrieben. 


\textbf{Community Cloud}: Eine Community Cloud wird von einer Gemeinschaft von Nutzern mit gemeinsamen
Anliegen eingesetzt. Der Besitz und Betrieb liegen dabei bei einem oder mehreren
Mitgliedern dieser Gemeinschaft, einer Drittpartei und kann Off- oder On-Premises betrieben

werden.


\textbf{Hybrid Cloud}: Die Hybrid Cloud besteht aus einer Kombination der beschriebenen Modelle (Public, Private und Community). Diese bilden dabei eigene Instanzen die aber durch standardisierte oder proprietäre Schnittstellen den Transfer von Daten und Anwendungen
zwischen den Instanzen erlauben.

\subsection{Vor- und Nachteile des Einsatzes von Cloud Computing}

\subsubsection{Vorteile und Treiber der Adoption von Cloud Computing}

\textbf{Wirtschaftliche Vorteile}: Ein Vorteil in der Nutzung von Cloud Computing
kann darin liegen dass ein Großteil der für den Betrieb notwendigen Infrastruktur
nicht mehr vom Unternehmen selbst eingekauft, eingerichtet und betrieben werden
muss (Abb. 2.1). Potentiell hohe Kosten die bereits vor der
Inbetriebnahme eines Systems mit einem höheren Risiko aufgewendet werden müssen
stellen in Form von individuell geringeren laufenden Beträgen ein deutlich
reduziertes Risiko dar\cite{capex-opex}.\\
Sofern der Einsatz von Cloud Computing in einer sinnvollen und korrekten
Weise erfolgt können je nach Fall die Gesamtkosten um einen hohen Anteil reduziert
werden\cite{total-cost}.\\
Die Gesamtkostenersparnisse stehen auch im Zusammenhang mit Skaleneffekten\footnote{Zusammenhang zwischen produziertem Ertrag und eingesetzter Ressourcen} die für
große Cloud Service Provider gelten. Der Betrieb eines einzelnen Servers ist im Verhältnis
mit bedeutend höheren Kosten verbunden als das hinzufügen eines äquivalenten
Systems zu einem Rechenzentrum im Betrieb von Mircosoft oder einem vergleichbaren
Anbieter\cite{econ-scale}.

\textbf{Skalierbarkeit}: Besonders für schnell wachsende Unternehmen ist die
Möglichkeit schneller Skalierbarkeit einer der prominentesten Vorteile der Cloud.
Es kann nicht nur auf vorhersagbare Anstiege (zum Beispiel ausgelöst durch
eine Verkaufsaktion) sondern auch auf unvorhersehbare Ereignisse reagiert werden.
Zusätzlich ist es möglich diese Skalierung nicht nur bis zu einem bestimmten Limit,
sondern nahezu unendlich zu betreiben. Wichtig ist auch dass sowohl auf steigende
als auch sinkende Nachfrage reagiert werden kann\cite{scale}.

\textbf{Resilienz}: In einem Worst Case-Szenario kann ein ganzes Rechenzentrum
durch unvorhergesehen Ereignisse wie beispielsweise Brände, Naturkatastrophen
oder anderes vollständig zerstört werden. Selbst wenn Backup-Rechenzentren
verfügbar sind ist eine Übertragung der Operationen kein trivialer Ablauf und
birgt oft nicht außer Acht zu lassende Risiken. Die Flexibilität der Cloud
erlaubt es die gesamte Infrastruktur mit sehr geringem Aufwand in nicht
betroffene Regionen zu verlagern und die Kontinuität der Geschäftstätigkeiten
mit minimaler Unterbrechung aufrecht zu erhalten\cite{resil}.

\textbf{Security}: Sicherheitsaspekte können sowohl einen Vor- als auch Nachteil
von Cloud Computing darstellen. Hier sollen zuerst Vorteile dargelegt werden,
potentielle Probleme sind im nächsten Abschnitt beschrieben.\\
Die technischen Möglichkeiten und besonders auch die Wahrnehmung des Themas
Sicherheit in der Cloud unterlagen und unterliegen auch noch immer einem
deutlichen Wandel. Cloud Anbieter investieren
viele Ressourcen in Sicherheit und stellen dem Nutzer zum Beispiel bereits sicher
implementierte Verschlüsselungen zur Verfügung oder bieten einen gewissen
Schutz vor Denial-of-Service Angriffen durch ihre \enquote{natürliche} Skalierbarkeit\cite{sec-1}.

\subsubsection{Herausforderungen und Risiken}

\textbf{Netzwerkabhängigkeit}: Da der Zugriff auf Cloud Dienste über das
Internet erfolgt entsteht dadurch entsprechend auch eine hohe Abhängigkeit. Stabile und schnelle Netzwerkanbindung ist eine kritische Voraussetzung für effektives Arbeiten\cite{net-dep}, bei lokal gehosteten Systemen ist diese Abhängigkeit
entsprechend geringer.

\textbf{Vendor Lock-in}: Bei der Nutzung eines Cloud Anbieters entsteht die
Gefahr sich zu sehr in Abhängigkeit eines einzelnen Anbieters zu begeben.
Im Fall einer Änderung der Nutzungsbedingungen oder einer Änderung im
Kostenmodell die den eignen Interessen stark entgegen steht, besteht die Gefahr
bereits so abhängig von diesem Anbieter zu sein dass die Kosten eines Wechsels
derart hoch ausfallen dass man gezwungen ist die Bedingungen zu akzeptieren\cite{lock-in}.

\textbf{Security und Privacy}: Sicherheitsrisiken sind einer der meistgenannten
Gründe die gegen Cloud Computing sprechen\cite{sec-2}, besonders im Fall der Nutzung einer
Public Cloud. Die Gefahr dass Daten in die Hände dritter gelangen kann zum
beispielsweise nicht vollständig ausgeschlossen werden. Da die Verantwortung über
die Sicherheit der Daten dem Cloud Anbieter unterliegt kann es auch zu Problemen
hinsichtlich Privatheit der Daten kommen, sollte etwa eine Regierungsorganisation
Zugriff auf bestimmte Daten eines Nutzer verlangen könnte dieser ohne dessen
Einverständnis gewährt werden.

\textbf{Kosten}: Auch wenn die Nutzung von Cloud Computing mit dem Vorteil
geringerer Kosten beworben wird, ist dies nicht zwingend garantiert. Werden die
vorhandenen Systeme ungünstig verwendet, bleiben zum Beispiel viele gebuchte
CPUs und IP-Adressen sowie weitere Ressourcen ungenutzt, können unnötig hohe Kosten entstehen. Auch während der Migrationsphase, in der möglicherweise beide Systeme parallel betrieben werden müssen, können höhere Kosten
entstehen als in einem vergleichbaren Zeitraum davor. Nicht zuletzt stellt die Migration komplexer Systeme häufig eine große technische und dadurch auch finanzielle Herausforderung dar\cite{migration-cost}.

\subsection{Überblick über die wichtigsten Cloud Service Provider}

In diesem Abschnitt soll ein knapper Überblick über die wichtigsten Public Cloud Service Provider gegeben werden. Abbildung 2.2 stellt den Marktanteil der aktuell umsatz-stärksten Cloud Service Provider sowie das globale Umsatzwachstum insgesamt dar. Zu beachten ist dass in dieser Abbildung das Service Modell SaaS nicht beinhaltet ist.

\begin{figure}[H]

	\includegraphics[width=1.0\textwidth]{fig/aa-hauptteil/CSP-share.png}
	\caption{CSP Market Share Q2 2021 nach Umsatz\cite{csp-share}}

	\centering

\end{figure}

Aus Abb. 2.2 wir ersichtlich dass Amazon, Microsoft und Google gemeinsam mehr als die Hälfte des Marktes beherrschen, Amazon allein stellt etwa ein Drittel aller Infrastruktur Services bereit.

\begin{figure}[H]

	\includegraphics[width=0.75\textwidth]{fig/aa-hauptteil/Gartner.png}
	\centering
	\caption{CSP Gartner Magic Quadrant Juli 2021\cite{gartner-mag}}

	\centering

\end{figure}

Der Gartner Magic Quadrant für Cloud Service Provider bietet einen groben
Überblick über den Umfang der Angebote (Completeness of Vision) und
die Ausgereiftheit einer Plattform (Ability to Execute). Deutlich erkennbar
ist hier die Vormachtstellung von Amazon gegenüber Microsoft und Google, auffällig ist auch die Stellung von IBM die auf ein mögliches Problem in der Ausgereiftheit der IBM Cloud hinweisen könnte.

\section{Infrastructure as Code}

Automatisierung spielt in der modernen Softwareentwicklung eine wichtige Rolle. Automatisierte Unit- und Integration-Tests gehören inzwischen schon lange zum Standardrepertoire eines Softwareentwicklers. Die Verbreitung der DevOps-Kultur förderte in den letzten Jahren auch die Automatisierung des Build- und Deployment-Prozesses und mit der steigenden Verbreitung Cloud-basierter Software erweitert sich diese Automatisierung nun auch auf das Provisioning der Infrastruktur.

Infrastructure as Code beschreibt im allgemeinen einen Ansatz zur Automatisierung des Infrastruktur-Provisionings basierend auf Methoden aus der
Softwareentwicklung\cite{def-iac}.

Statt eines manuellen Aufbaus und händischer Konfiguration der einzelnen
Komponenten werden maschinenlesbare Dateien verfasst welche dann von einem
IaC Tool eingelesen und verarbeitet werden. Dabei kommen bevorzugt
deklarative Sprachen zum Einsatz deren höhere Abstraktion mehr Flexibilität
als ein imperativer Ansatz erlaubt\cite{dec-imp-iac}.

\subsection{Technologischer Wandel und das Cloud Age Mindset}

Durch die Technologien der Cloud ist es heute möglich eine gewünschte
IT-Infrastruktur sehr viel schneller bereitzustellen als
zuvor. Statt Einkauf, Anschließen und Einrichten eines
physischen Servers das, je nach Szenario einen Zeitraum von mindestens
mehreren Stunden oder Tagen bis hin zu Wochen dauern kann, können
virtuelle Ressourcen in der Cloud in wenigen Minuten verfügbar gemacht werden.
Der schnellere Ablauf wird durch die Automatisierung von Prozessen wie der Bereitstellung der Infrastruktur mithilfe von IaC Tools noch verstärkt. Mit diesen Veränderungen wird das Management und die Erweiterung der
bestehenden Systeme jedoch nicht unbedingt einfacher\cite{iac-schneller}, die Anwendung von
Arbeitsprozesse die sich bisher bewährt haben sind oftmals ineffektiv und verhindern das Ausnutzen des vollen Potentials der Cloud.
Kief Morris, Autor von \textit{Infrastructure as Code - Dynamic Systems for the Cloud Age}, stellt die fundamentalen Unterschiede des Arbeitens mit
Cloud-Technologien mithilfe der folgenden Tabelle (Tab. 2.1) dar.

\begin{table}[H]
	\includegraphics[width=0.9\textwidth]{fig/aa-hauptteil/iron_vs_cloud.png}
	\centering
	\caption{\enquote{Iron vs Cloud Age}\cite{dec-imp-iac}}
	\centering
	
\end{table}

Veränderungen im \enquote{Iron Age} sind aufwändig und teuer und stellen ein
Risiko dar, es wird versucht diese Risikopunkte zu reduzieren, daher werden
viele Veränderung gebündelt getestet und eingeführt wodurch lange
Release-Zyklen entstehen. Die Architekturen die dadurch befördert werden
sind monolytisch, die Konfiguration erfolgt eher mithilfe von GUI-gesteuerten Programmen oder direkter physischer Interaktion, zum Beispiel wenn ein neuer Server
in ein Netzwerk eingebunden wird. Veränderungen in der Cloud stellen
fast genau das Gegenteil dar, daher wird erkennbar dass eine auf das \enquote{Iron Age} zugeschnittene Arbeitsweise für die Cloud nicht effektiv ist.
Ein neues \enquote{Cloud Age Mindset} das die rechte Spalte der Tabelle
verinnerlicht ist erforderlich um die Vorteile der Cloud
wirklich effektiv und in vollem Umfang nutzen zu können.

\subsection{Vorteile von Infrastructure as Code im Vergleich zu manuellem Infrastruktur-Provisioning}

\textbf{Kein Configuration Drift durch einheitliche Codebasis}:
 Configuration Drift bezeichnet eine über die Zeit
wachsende Abweichung zweier ursprünglich identischer Systeme. Wird ein
gleiches System, zum Beispiel ein Applikationsserver, in verschiedenen
Umgebungen eingesetzt stellen diese Umgebungen oftmals auch leicht verschiedene
Anforderungen an diesen Server. Auf diese kann dann mit Optimierungen, etwa in Form spezifischer
Konfigurationsdetails, reagiert werden. Wird nun das ursprüngliche
Basis-System geupdated werden individuelle und oft undokumentierte Anpassungen
nicht berücksichtigt wodurch ein Update unbequeme Konsequenzen nach
sich ziehen kann. Werden alle Veränderungen in einer einheitlichen
Codebasis verwaltet und Updates häufig vorgenommen verhindert man
starken Configuration Drift der ansonsten oftmals stattfindet\cite{conf-drift}.

\textbf{Wiederverwendbarkeit durch einheitlichen Code}:
Ein weiterer Vorteil der durch die Verwendung einer einheitlichen
Codebasis entsteht ist die Wiederverwendbarkeit und Reproduzierbarkeit
eines Systems. Wenn ein identisches System an einer anderen Stelle
aufgebaut werden soll oder geht ein System aus unvorhergesehenen
Gründen in seiner Gesamtheit verloren kann es schnell und mit
verhältnismäßig geringem Aufwand reproduziert werden.
Ein dazu passender Ausdruck in Bezug auf Server ist \enquote{Cattle not Pets}. Statt sich individuell und mit großem Aufwand um einzelne Server zu
kümmern, wie man es etwa mit dem eigenen Haustier tut, sollten Server
wie leicht ersetzbares Vieh behandelt werden\cite{cattle-pets}.

\textbf{Schnelleres Provisioning durch Cloud}: Ein bereits häufig angesprochener Vorteil ist die schnelle Bereitstellung, durch diese Verkürzung bzw. Eliminierung des Hardware-Anschaffungs-Prozesses. Dadurch können sowohl frühe Developer-Builds als auch spätere Release-Versionen schneller getestet und deployed werden wodurch der gesamte Release-Cycle beschleunigt wird.

\textbf{Schnellerer Profit}: Die logische Schlussforderung aus dem vorangegangenen Punkt ist die schnellere Erzielung von Umsätzen. Den Markt als erstes mit einem neuen Produkt zu betreten bringt wirtschaftliche Vorteile mit sich, Voraussetzung dabei ist eine adäquate Qualität welche durch IaC ebenfalls gefördert wird.

\textbf{Einheitlicheres Tooling in Dev, Ops und weiteren Beteiligten Teams}: Verwendung von IaC fördert ein einheitlicheres Tooling in allen Bereichen die mit einem Softwareprodukt in Zusammenhang stehen. Ein einfaches Beispiel hierfür ist die Verwendung eines Source-Code Editors der sowohl für das Schreiben von Programm- und Infrastruktur-Code gleichermaßen notwendig ist.

\textbf{Stärkere Automatisierung im Arbeitsablauf}: Automatisierung bedeutet immer einen gewissen initialen Zusatzaufwand, jedoch kann auf längere Sicht deutlich von automatisierten Abläufen profitiert werden. Testen, Builds und Deployment wurden bereits angesprochen und sind klassische Prozesse deren Automatisierung längerfristig vorteilhaft ist.

\textbf{Höhere Zuverlässigkeit und Sicherheit durch schnelle Updates}: Veränderungen stellen die größte Gefahr für ein Produktionssystem dar, gleichzeitig sind Veränderungen aber unvermeidbar um die Sicherheit des Systems zu gewährleisten und es zu verbessern. Durch die Fähigkeit Veränderungen schnell und dennoch zuverlässig durchzuführen wird die Reaktionszeit auf unvorhergesehene Ereignisse und Anforderungen wesentlich verkürzt\cite{opt-change}.

\textbf{Schnellere Fehlersuche und -behebung}: Potentielle Fehler können durch Automatisierung und Modularität (siehe. Kapitel 2.2.4) schneller isoliert, gefunden und behoben werden. Infolgedessen profitieren Sicherheit und Stabilität von einer Struktur die eine einfache und schnelle Integration von Veränderungen fördert.

\subsection{Herausforderungen und Argumente gegen den Einsatz von Infrastructure as Code}

Kief Morris benennt drei Argumente die gegen die Einführung von IaCgenannt werden, diese sollen hier Im Kontext der zuvor genannten Vorteile betrachtetwerden.

\textbf{1. \enquote{Veränderugen werden nicht oft genug durchgeführt umAutomatisierung zu rechtfertigen.}}

Die Idee dass ein System einmal erstellt und dann \enquote{fertig} ist wodurch eineAutomatisierung der Veränderungen überflüssig wird entspricht sehr selten der tatsächlichen Realität.IT-Systeme und damit auch IT-Infrastruktur wird während ihres gesamtenLebenszyklus mehr oder weniger kontinuierlich verändert und erweitert.\\Sicherheitslücken in alten Versionen von Softwarepackages oderBetriebssystemen sind keine Seltenheit und müssen gepatcht werden umeinen sicheren und Zuverlässig Betrieb zu gewährleisten. Neue Features in bestehender Software kann neue Infrastruktur, zum Beispiel in Form einer zusätzlichen Datenbank, notwendig machen oder eine veränderte Konfigurationerfordern. Gerade bei Sicherheitslückenist es wichtig Anpassungen nicht erst nach längerer Zeit sondern soschnell wie möglich durchzuführen um Sicherheit und Stabilität nichtzu gefährden. Ein weiteres Szenario das die Stabilität eines Systemsgefährden kann ist ein schneller Zuwachs an Last die ein System erfährt,können die Kapazitäten automatisiert erweitert werden wird ein Zusammenbruch des Services auf einfache Art verhindert\cite{opt-change}.

\enquote{A fundamental truth of the Cloud Age is: Stablity comes from making changes.}\cite{stab-cloud}

Eine fundamentale Wahrheit des Cloud Zeitalters ist: Stabilität entsteht durchVeränderung.

\textbf{2. \enquote{Infrastruktur soll zuerst aufgebaut, danach automatisiert werden.}}

Die Umsetzung von Infrastructure as Code stellt eine durchaus eine große Herausforderung dar, umso mehr wenn die entsprechenden Kompetenzen noch aufgebaut werden müssen. Der Nutzen wird deshalb nicht unbedingt direkt ersichtlich wodurch es zu Situationen kommt in denen es attraktiv erscheint Infrastruktur zuerst aufzubauen und sich erst später um die Automatisierung zu kümmern. Mit diesemAnsatz werden viele der Vorteile von IaC jedoch verwirkt. Ein bestehendes, komplexes Infrastruktur-System zu automatisieren ist eine deutlich größere Herausforderung als ein System von Grund auf mit dem Gedanken an Automatisierung aufzubauen\cite{build-auto}.

\textbf{3. \enquote{Es muss zwischen schneller Umsetzung und hoher Qualitätgewählt werden.}}

Die Idee dass der Fokus auf hohe Geschwindigkeit und hohe Qualitätsich gegenseitig behindert oder ausschließt mag logisch erscheinen,in der Praxis ist dies jedoch nicht der Fall.Ein unausgeglichener Fokus auf eines der beiden Kriterien führt im Lauf der Zeit zu einem \enquote{Fragile Mess} (Abb. 2.4).

\begin{figure}[H]
	\includegraphics[width=1.0\textwidth]{fig/aa-hauptteil/Speed_vs_Quality.png}
	\caption{Verhältnis von Geschwindigkeit und Qualität\cite{speed-quality}}
	\centering
\end{figure}

Wird Geschwindigkeit über Qualität gestellt (Quadrant links oben) entstehenmit der Zeit chaotische und instabile Systeme an denen Veränderungen mitder Zeit nur noch erschwert und deshalb langsam durchgeführt werden können.\\Wird Geschwindigkeit zu niedrig priorisiert (Quadrant rechts unten) führt es allerdings auch dazudass letzten Endes durch Druck von Deadlines und schnellen Workaroundstechnische Schulden aufgebaut werden die ebenfalls zu einem qualitativschlechten System führen.\\ Aufgrund dieser Probleme ist es wichtig Geschwindigkeit und Qualitätgleichermaßen zu priorisieren.

\subsection{Die drei Kernverfahren von Infrastructure as Code}

\begin{itemize} 
	\item \textbf{Define everything as Code}: Alle Teile eines Systemin Form von Code zu definieren bringt mehrere Vorteile mit sich. Der Konfigurations-Code kann mehrfach ausgeführt werden, daher ist ein als Code definiertes System wiederverwendbar. Es können unkompliziert mehrereidentische Instanzen erstellt werden, das gilt auch für den Fallwenn Fehler auftreten und ein Neuaufbau erforderlich ist.Das Verhalten des Systems ist vorhersehbarer, fortlaufendes automatischesTesten ist möglich und damit auch zuverlässiger.Definition in Code macht auch den Aufbau eines Systems transparenter,da dieser immer dem tatsächlichen Zustand entspricht unddiesen damit auch dokumentiert\cite{coreprinc-1}.
	
	\item \textbf{Continuously Test and Deliver All Work in Progress}: Fortlaufendes, automatisiertes Testen und Integrieren aller Komponentendie sich in Entwicklung befinden dient dem Ziel die Qualität einesSystems nicht nur \enquote{einzutesten} sondern von Beginn an und kontinuierlicheinzubauen\cite{coreprinc-1}.
	
	\item \textbf{Build Small, Simple Pieces That You Can Change Independently}: Systeme die aus mehreren kleineren voneinander unabhängigen Komponentenbestehen sind generell stabiler als große Monolithen. Eine Änderung dieeinen Fehler verursacht betrifft nur die Komponente in der die Änderungstattfindet, diese kann dann leichter isoliert und das Problem behobenwerden. Kleine Komponenten sind in der Regel auch weniger Komplex unddadurch leichter zu verstehen. Ein einzelner Fehler nach einem Updatehat auch den Vorteil dass nur diese Komponente und nicht das gesamte System auf eine ältere Version zurückgesetzt werden muss umden Betrieb wieder herzustellen\cite{coreprinc-2}.
\end{itemize}

\section{Funktionsprinzip und Rolle von Terraform im IaC-Anwendungsprozess}

Während der Anwendung von Infrastructure as Code kann primär zwischen zwei wichtigen Phasen unterschieden werden, einer initialen Einrichtungsphase und der darauf folgenden Wartungs- und Betriebsphase. Während der Einrichtung wird die Infrastruktur bereitgestellt und konfiguriert, genauso wird auch Software installiert und eingerichtet. Nachdem das System dann in Betrieb genommen wurde können Anpassung notwendig sein, Server werden hinzugefügt und abgebaut, Software wird aktualisiert und neu konfiguriert.

\subsection{Überblick über Infrastructure as Code Tools}

Infrastructre as Code beinhaltet verschiedene konkrete Anwendungsfälle undentsprechend existieren auch Tools die zum Teil ein breiteres Spektrumvon IaC abdecken, zum Teil aber auch eher spezialisiert sind; Terraformist dabei eher ein Beispiel eines spezialisierten Tools. Die unten stehendeAbbildung 2.5 soll einen Überblick über verschiedene IaC Tools und deren Aufgabengebieteverschaffen, die Einordnungen sind dabei aber nicht unbedingt als absolutanzusehen. Es ist zum Beispiel möglich innerhalb eines Terraform-Deploymentsauch Software zu installieren und zu konfigurieren, allerdings wird dietatsächliche Installation dann eher per von Terraform aufgerufenen Skriptenvorgenommen statt von Terraform selbst verwaltet zu werden, daher istTerraform hier ausschließlich als Infrastruktur-Management Tool eingeordnet.

\begin{figure}[H]
	\includegraphics[width=1.0\textwidth]{fig/aa-hauptteil/IaC_Tools.png}
	\caption{Überblick IaC Tools\cite{iac-tools}}
	\centering
\end{figure}

\subsubsection{Vorteile und Limiterungen von Terraform}

Da sich diese Arbeit primär mit dem Provisioning von grundlegender CloudComputing Infrastruktur in Form von VM's, Netzwerken, Datenspeicher undanderen grundlegenden Komponenten beschäftigen soll bietet sich der Einsatzeines darauf spezialisierten Tools an. Neben Terraform existiert in diesem Bereich auch das Tool Pulumi, in dieser Arbeit wird Terraform jedoch aus den folgenden Gründen verwendet:

\begin{itemize}
	\item \textbf{Modularität}: Terraform Module erlauben es ein System inmehrere klar definierte Komponenten zu strukturieren. Dadurch wird dieWiederverwendbarkeit dieser ermöglicht und gefördert, die daraus resultierenden Vorteile wurden bereits in den vorangegangenenKapiteln angesprochen.\\Pulumi strukturiert Infrastruktur Code entweder in einem großenmonolithischen Projekt oder vielen kleinen Mikroprojekten, beideOptionen sind weniger flexibel und umständlicher als die von Terraform implementierte Lösung.
	
	\item \textbf{Weitere Verbreitung und größere Popularität}: Terraform wurde2014, Pulumi 2017 veröffentlicht, entsprechend ist Terraform deutlich weiterverbreitet und verfügt über all die Vorteile die eine größere Community mitsich bringt. Dazu gehören mehr Lernressourcen, mehr Codebeispiele, größereBekanntheit und mehr Jobs für die Arbeit mit Terraform.
	
	\item \textbf{Dokumentation}: Einen weiteren Voteil von Terraform stelltdessen umfangreiche und ausgereifte Dokumentation sowie auch dieDokumentation der einzelnen Provider dar. Der genaue Aufbau der einzelnenRessourcen wie etwa einer VM auf Google Cloud Platform(google\_compute\_instance) ist mit einem Beispiel und der zugehörigenArgument Reference versehen aus der direkt ersichtlich wird welcheArgumente notwendig (required), was der Zweck jedes einzelnen Arguments istund wo anstelle eines einfachen Wertes ein Block oder eine Liste erwartet wird.
\end{itemize}

\subsection{Funktionsweise von Terraform}

Terraform ist ein Infrastructure as Code Tool das es ermöglicht Infrastruktursicher und effizient aufzubauen, zu verändern und zu versionieren. Die Funktionsweise von Terraform wird in Abbildung 2.6 dargestellt.

\begin{figure}[H]
	\includegraphics[keepaspectratio, height=15cm]{fig/aa-hauptteil/Terraform.png}
	\caption{Terraform Funktionsprinzip\cite{tf-princ}}
	\centering
\end{figure}

Terraform verwendet eine deklarative Domänenspezifische Sprache (DSL) die es erlaubt Infrastruktur in Konfigurationsdateien zu beschreiben dieversioniert, geteilt und wiederverwendet werden können. Terraform Module können auf einer Public Module Registry \footnote{Vergleichbar mit der npm-Registry von Nodejs} zur allgemeinen Verfügung bereitgestellt und von der breiteren Terraform-Community wiederverwendet werden. Terraform unterstützt über Plug-Ins, die Terraform Provider, ein große Anzahl an Plattformen.

\subsection{Einführung in die Hashicorp Configuration Language}

Die von Terraform verwendete Konfigurationssprache wurde mit dem Zielentwickelt einen Kompromiss zwischen Maschinenfreundlichkeit undMenschenlesbarkeit zu erzielen\cite{hcl}. Existierende Serialisierungsformate,Konfigurationssprachen und Programmiersprachen konnten die Zieleder Terraform-Entwickler nicht erfüllen daher kommt nun bei Terraformeine DSL in Form der Hashicorp Configuration Language (HCL) zum Einsatz.

HCL besteht aus drei grundlegenden Elementen: Blöcken (Blocks), Argumenten(Arguments) und Ausdrücken (Expressions).

\begin{lstlisting}[caption={Grundlegende Elemente von HCL},captionpos=b]
Typ "label1" "label2" {
	...
	/*This is a block*/
	...
	
	Argument = 5
	
	Arguments + Can + Build = Expressions
}
\end{lstlisting}

\textbf{Blöcke} stellen für gewöhnlich ein Objekt, im Fall vonInfrastrkturcode meistens eine Computing Ressource, dar.Blöcke besitzen einen Typ und Null bis mehrere Label. Blöcke beinhaltenArgumente und weitere verschachtelte Blöcke.\\
\textbf{Argumente} sind das was in den meisten Programmiersprachen dieVariablen darstellen: Ein Wert der einem Namen zugewiesen wird.\\
\textbf{Ausdrücke} sind ähnlich wie in anderen Sprachen ein aus anderenAusdrücken und Argumenten berechneter Wert, ein Argument ist in diesem Sinnedie simpelste Form eines Ausdrucks.

\subsubsection{Input und Output-Variablen}

Input-Variablen sind nützlich um Parameter außerhalb des eigentlichenTerraform Codes anzupassen. Die ID des Projektes stellt einen solchenParameter dar, befindet sich diese außerhalb des Codes muss nur die Dateiwelche die Input-Variablen enthält angepasst werden, alles andere kann ohneVeränderungen wiederverwendet werden.

\begin{lstlisting}[caption={Beispiel Input-Variable},captionpos=b]
variable "project" {
	default = "some_value"
	description = "a description"
}
\end{lstlisting}

Input-Variablen können entweder während der Ausführung über die Kommandozeile oder über eine Datei mit einfachen Key-Value Paaren befüllt werden.

Output-Variablen werden in der Regel verwendet um nach dem Aufbau des Systems auf spezifische Parametereinfachen und schnellen Zugriff zu ermöglichen.

\begin{lstlisting}[caption={Beispiel Output-Variable},captionpos=b]
output "something_important" {
	value = some.nested.value
}
\end{lstlisting}

Werte wie die IP einerVirtuellen Maschine auf einer Public Cloud Plattform sind vor derBereitstellung dieser nicht bekannt, werden aber häufig benötigt weshalb esnützlich ist eine Output Variable für diese zu deklarieren.

\subsubsection{Terraform Module}

Module sind Container für mehrere Ressourcen die gemeinsam verwendet werden.Jedes Terraform Projekt besitzt ein Root Modul das weitere Module verwendenkann. Die Terraform Registry stellt eine Vielzahl an veröffentlichtenModulen zur öffentlichen Verwendung bereit.

\subsubsection{Terraform Provider}

Terraform benötigt Plugins, die Provider, um mit Cloud Providern,SaaS Providern und anderen API's interagieren zu können \cite{tf-provider}. Neben den Providern für Plattformen gibt es auch Utility-Provider die Funktionalitäten wie zum Beispiel einen String-Generator bereitstellen.

\subsubsection{Terraform Workflow}

Der grundlegende Terraform Workflow besteht aus vier B:

TODO Code terraform init

Das init Kommando installiert und konfiguriert die notwendigen Provider
und Module und konfiguriert ein Backend (Fußnote Backend) falls angegeben.

TODO Code terraform plan

Mit terraform plan wird ein Execution Plan erstellt. Dazu gehört den die
aktuell existierenden Resourcen zu erfassen, Veränderungen zwischen
diesem Zustand und dem im Code konfigurierten Zustand zu erfassen und
auf Grundlage dessen einen Plan zu erstellen welche Änderungen vorgenommen
werden können um den Soll-Zustand zu erreichen.

Todo Code terraform apply

Durch terraform apply wird ein solcher Execution Plan ausgeführt und die darin
enthaltenen Änderungen an der Infrastruktur vorgenommen.

Todo Code terraform destroy

Um den umkomplizierten Abbau eines mit Terraform definierten und aufgebauten
Systems bewerkstelligen zu können wird das terraform destroy Kommando
verwendet. Dies ist besonders nützlich um nicht mehr benötigte Testsysteme
und andere temporäre Infrastrukturen zu entfernen.

\chapter{Evaluierungsanforderungen und Umsetzung}
\label{sec:ergeb}

\section{Evaluierungsanforderungen}

\subsection{Ziel der Evaluierung}

\subsection{Untersuchte Komponenten der Terraform Provider}

\subsection{Auswahl der Evaluierungskriterien}

\section{Umsetzung des Testsystems}

\subsection{Eingesetzte Software und Tools}

\subsection{High-Level Aufbau des Testsystems}

\subsection{Konkreter Aufbau auf Google Cloud Platform}

\subsection{Konkreter Aufbau auf Azure}

\subsection{Aufbau der ergänzenden Versuche}

\chapter{Ergebnisse und Bewertung}

\begin{landscape}
	\section{Evaluierung der Functional Completeness}
	\begin{table}[H]
		\begin{tabular}{@{}lll@{}}
			\toprule
			& Google Cloud 
			Platform                                                            
			
			
			&
			Microsoft 
			Azure                                                               
			
			\\
			\midrule
			VM Ubuntu 
			20.04                                                               
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				google\_compute\_instance 
				erfüllt.\end{tabular}                                               
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch ressource \\ 
				azurerm\_virtual\_machine 
				erfüllt.\end{tabular}                                               
			\\
			\midrule
			\begin{tabular}[c]{@{}l@{}}PostgreSQL \\ 
				Datenbankserver\end{tabular}                                        
			& \begin{tabular}[c]{@{}l@{}}Funktionalität wird 
				durch Ressource \\ google\_sql\_database\_instance 
				erfüllt.\end{tabular}                                               
			& 
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource\\ 
				azurem\_postgresql\_database 
				erfüllt.\end{tabular}                                               
			\\
			\midrule
			\begin{tabular}[c]{@{}l@{}}Anlegen von Datenbanken mit\\ Charset 
				UTF-8 und Collation\\ English\_Unites States.1252\end{tabular} & 
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch die Ressource 
				\\ google\_sql\_database teilweise erfüllt. Collation \\ kann bei 
				Erstellung nich wie erwünscht definiert \\ werden. Default ist 
				en\_US.UTF8\end{tabular} & 
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch die \\ Ressource 
				\\ azurem\_postgresql\_database\\ erfüllt. Charset und Collation \\
				werden bei Erstellung definiert.\end{tabular} \\ \midrule
			Secret 
			Storage                                                             
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				google\_secret\_manager\_secret erfüllt.\\ Es existiert ein Secret 
				Storage je Google 
				Projekt.\end{tabular}                                               
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				azurem\_key\_vault\_secret erfüllt.\\ Mehrere secret storages in \\
				Ressource Group möglich.\end{tabular}          \\ \midrule
			Kubernetes 
			Cluster                                                             
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				google\_container\_cluster 
				erfüllt-\end{tabular}                                               
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource\\ 
				azurem\_kubernetes\_cluster 
				erfüllt.\end{tabular}                                               
			\\
			\midrule
			\begin{tabular}[c]{@{}l@{}}Einbindung vom Container\\ Registry als 
				Data Source\end{tabular}                                     & 
			\begin{tabular}[c]{@{}l@{}}Funkltionalität wird durch Data Source 
				\\ google\_storage\_bucket erfüllt 
			\end{tabular}                                                
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch\\Data Source\\
				azurem\_container\_registry\ erfüllt 
			\end{tabular}                                                
			\\
			\bottomrule
		\end{tabular}
	\centering
	\caption{Anaylse der Functional Completeness}
	\centering
	\end{table}
\end{landscape}

\section{Ergebnisse und Bewertung der Time Behaviour Tests}

\begin{table}[H]
	\begin{tabular}{@{}clcccc@{}}
		\toprule
		\multicolumn{1}{l}{}                                                    
		&           & 
		\multicolumn{2}{l}{Google Cloud Platform} & 
		\multicolumn{2}{l}{Microsoft Azure} \\ \midrule
		\multicolumn{1}{l}{}                                                    
		& Testlauf & 
		Aufbau               & Abbau              & Aufbau            & 
		Abbau           \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Aufbau/Abbau \\ 
				Testsystem\end{tabular}}                                 & 1         & 
		15m48s               & 7m54s              & 7m7s              & 
		6m5s            \\
		& 2         & 17m37s               & 8m11s              & 
		7m59              & 7m44s           \\
		& 3         & 15m12s               & 6m52s              & 
		6m54s             & 6m6s            \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Aufbau/Abbau\\ 
				VM\end{tabular}}                                          & 1         & 
		0m30s                & 1m3s               & 1m12s             & 
		6m5s            \\
		& 2         & 0m23s                & 1m4s               & 
		1m11s             & 1m37s           \\
		& 3         & 0m25s                & 1m4s               & 
		1m11s             & 1m40s           \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Aufbau/Abbau \\ 
				PostgreSQL-\\ Datenbankserver\end{tabular}}              & 1         & 
		3m59s                & 1m3s               & 2m28s             & 
		0m42s           \\
		& 2         & 3m58s                & 0m52s              & 
		2m32s             & 0m43s           \\
		& 3         & 3m57s                & 0m52s              & 
		2m28s             & 0m40s           \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Aufbau/Abbau\\ Kubernetes- 
				Cluster\\ mit default Node Pool\end{tabular}} & 1         & 
		3m59s                & 2m52s              & 4m36s             & 
		5m33s           \\
		& 2         & 3m39s                & 3m3s               & 
		6m5s              & 5m32s           \\
		& 3         & 3m31s                & 2m53s              & 
		5m13s             & 5m29s           \\ \bottomrule
	\end{tabular}
	\centering
	\caption{Ergebnisse der Time Behaviour Tests (1/2)}
	\centering
\end{table}

\begin{table}[H]
	\begin{tabular}{@{}clcc@{}}
		\toprule
		\multicolumn{1}{l}{}                                                    
		& Testlauf & 
		\multicolumn{1}{l}{Google Cloud Platform} & 
		\multicolumn{1}{l}{Microsoft Azure} \\ \midrule
		\multicolumn{1}{l}{\multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}Execution Plan 
					\\ für Testsystem\end{tabular}}}                & 1    & 
		1.2s                                      & 
		14.6s                               \\
		\multicolumn{1}{l}{}                                                    
		& 2    & 
		1.2s                                      & 
		15.2s                               \\
		\multicolumn{1}{l}{}                                                    
		& 3    & 
		1.6s                                      & 
		15.9s                               \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Execution Plan\\ für 
				Datenbank-\\ server\end{tabular}}                           & 1    & 
		0.9s                                      & 
		22.2s                               \\
		& 2    & 1.0s                                      & 
		23.2s                               \\
		& 3    & 1.0s                                      & 
		23.3s                               \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Execution Plan für\\Kubernetes 
				Cluster\\ mit default Node Pool\end{tabular}} & 1    & 
		0.8s                                      & 
		13.5s                               \\
		& 2    & 0.9s                                      & 
		13.3s                               \\
		& 3    & 0.9s                                      & 
		12.3s                               \\ \bottomrule
	\end{tabular}
\centering
\caption{Ergebnisse der Time Behaviour Tests (2/2)}
\centering
\end{table}

\section{Ergebnisse und Bewertung der Recoverability Tests}

\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{lll}
			\hline
			& Google Cloud 
			Platform                                                            
			
			&
			Microsoft 
			Azure                                                               
			
			\\
			\hline
			\begin{tabular}[c]{@{}l@{}}Längere Unterbrechung \\ des Internets, 
				State in \\ Remote Backend\end{tabular} & 
			\begin{tabular}[c]{@{}l@{}}State korrumpiert, erneutes \\ terraform 
				apply führt zu \\ Fehler, manuelles entfernen \\ der Ressource 
				notwendig.\end{tabular} & \begin{tabular}[c]{@{}l@{}}State 
				korrumpiert, erneutes \\ terraform apply führt zu Fehler. \\ 
				Zusätzlich zur VM Ressource muss \\ die Festplatte ebenfalls 
				separat \\ manuell gelöscht werden.\end{tabular} \\ \hline
			\begin{tabular}[c]{@{}l@{}}Temporäre Unterbrechung \\ des 
				Internets, lokaler State\end{tabular}            & 
			\begin{tabular}[c]{@{}l@{}}Terraform state wird auch lokal \\ 
				korrumpiert, manuelles löschen \\ der VM-Ressource 
				notwendig.\end{tabular}                   
			&                                                                   
			
			
			\\
			\hline
			\begin{tabular}[c]{@{}l@{}}Soft Cancel von \\ Terraform 
				apply\end{tabular}                                 & State 
			korrumpiert                                                         
			
			& Shutdown sofort, state 
			korrumpiert                                                         
			
			\\
			\hline
			\begin{tabular}[c]{@{}l@{}}Hard Cancel von\\ Terraform 
				apply\end{tabular}                                  & State 
			korrumpiert                                                         
			
			& Nicht 
			durchgeführt                                                        
			
			\\
			\hline
		\end{tabular}%
	}
\centering
\caption{Ergebnisse der Recoverability Tests}
\centering
\end{table}

\section{Ergebnisse und Bewertung der Modifiability Tests}


\begin{table}[H]
	\begin{tabular}{@{}ccc@{}}
		\toprule
		& Google Cloud 
		Plattform                                                               
		&
		Microsoft Azure                                                        
		\\ \midrule
		\begin{tabular}[c]{@{}c@{}}Änderung des Betriebssystems \\ einer 
			virtuellen Maschine\end{tabular} & \multicolumn{2}{c}{Ressource wird 
			zerstört und neu 
			erstellt.}                                                              
		\\
		\midrule
		\begin{tabular}[c]{@{}c@{}}vergrößerung der Festplatte\\  einer 
			virtuellen Maschine\end{tabular}  & 
		\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Ressource wird zerstört 
				\\ und neu erstellt.\end{tabular}} & Führt zu 
		Error.                                                        \\ 
		\midrule
		\begin{tabular}[c]{@{}c@{}}Veränderung des Machine-Type \\ einer 
			virtuellen Maschine\end{tabular} & \multicolumn{2}{c}{Ressource wird 
			modifiziert.}                                                           
		
		\\ \midrule
		\begin{tabular}[c]{@{}c@{}}Vergrößerung des default \\ Node Pools von 1 
			auf 2 Nodes\end{tabular}  & 
		\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Ressource wird zerstört 
				\\ und neu erstellt.\end{tabular}} & 
		\begin{tabular}[c]{@{}c@{}}Ressource wird \\ modifiziert.\end{tabular} 
		\\ \bottomrule
	\end{tabular}
	\centering
	\caption{Ergebnisse der Modifiability Tests}
	\centering
\end{table}

Blabla

\section{Evaluierung der Einheitlichkeit der Testsysteme für Azure und Google Cloud Platform}




