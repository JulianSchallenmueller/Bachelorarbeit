% Bsp. eines Hauptteils

\chapter{Grundlagen}
\label{sec:grundl}

\section[Funktionsprinzip, Vorteile und Herausforderungen]{Funktionsprinzip, Vorteile und Herausforderungen des modernen Cloud Computings}

Um die Rolle von Infrastructure as Code und Terraform vollständig erläutern zu können sollte zuerst das grundlegende Funktionsprinzip und die verschiedenen Service- und Bereitstellungs-Modelle moderner Cloud Plattformen erklärt werden. Die am meisten verwendete Definition von Cloud Computing wurde vom National Institute of Standards and Technology der Vereinigten Staaten von Amerika veröffentlicht und wird im folgenden Kapitel zusammengefasst.

\subsection{Definition und Funktionsweise}

Das National Institute of Standards and Technology (NIST) der Vereinigten
Staaten von Amerika definiert Cloud Computing im Abstract der NIST SP-800-145\cite{def-cloud}
folgendermaßen:\\

\enquote{Cloud computing is a model for enabling ubiquitous, convenient, on-demand network access to a shared
pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that
can be rapidly provisioned and released with minimal management effort or service provider interaction.
This cloud model is composed of five essential characteristics, three service models, and four deployment
models.}\\

Cloud Computing beschreibt ein Modell das es ermöglicht ortsunabhängig, zweckdienlich und zeitunabhängig auf einen konfigurierbaren Pool an Computing Ressourcen (Netzwerke, Server,
 Datenspeicher, Anwendungen und Services) zuzugreifen die schnell und mit minimalem
Aufwand und minimaler notwendiger Interaktion bereitgestellt und wieder abgebaut werden können.
Dieses Cloud Modell beschreibt fünf essentielle Charakteristiken, drei Servicemodelle
und vier Bereitstellungsmodelle.\\

Weiter definiert das Dokument die fünf Charakteristiken in den folgenden Punkten:

\textbf{On-demand-self-service}: Der Nutzer kann eigenmächtig die benötigten Computing Ressourcen automatisch bereitstellen, es wird keine menschliche Interaktion benötigt.

\textbf{Broad network access}: Auf Leistungen wird über das normale Internet mit standardmäßigen
Mechanismen wie der Nutzung von Thin Clients und Fat Clients (Smartphones, Tablets,
Laptops oder Workstations) zugegriffen.

\textbf{Resource Pooling}: Die Computing Ressourcen des Anbieters werden in einem gemeinsamen Pool
für mehrere Kunden in einem Multi-Tenancy-fähigen Modell bereitgestellt, physische und
 virtuelle Ressourcen werden dynamisch zugewiesen und entsprechend der Nachfrage
kontinuierlich neu verteilt. Es wird eine empfundene Ortsunabhängigkeit hergestellt indem der Nutzer
kein genaues Wissen darüber besitzt wo sich dessen Ressourcen befinden, auf höherem
 Level wie beispielsweise dem Staat, der Region oder auch Rechenzentrum kann
der Ort vom Nutzer spezifiziert werden. Die bereitgestellten Ressourcen beinhalten
zum Beispiel Datenspeicher, Rechenleistung, Arbeitsspeicher und Netzwerkbandbreite.


\textbf{Rapid Elasticity}: Rechenkapazitäten werden dehnbar bereitgestellt und abgebaut,
 teilweise automatisch, um entsprechend der Nachfrage schnell hoch- und wieder
zurück skalieren zu können. Rechenkapazitäten erscheinen dadurch unbegrenzt und können
zu jeder Zeit und in jedem Umfang bereitgestellt werden.


\textbf{Measured Service}: Cloud Systeme kontrollieren und optimieren Ressourcennutzung
 automatisch mithilfe eines Mess-Systems dass auf einer abstrakten Ebene den
entsprechenden Service (Datenspeicher, Rechenleistung, Benutzerkonten, etc.) überwacht,
kontrolliert und Bericht erstattet um sowohl für Anbieter als auch Kunden Transparenz
herzustellen.\\

Es wird zwischen drei grundlegende Cloud Service Modellen unterschieden: Infrastructure
as a Service (IaaS), Platform as a Service (PaaS) und Software as a Service (SaaS) (Abb. 2.1).

\begin{figure}[H]

	\includegraphics[width=1.0\textwidth]{fig/aa-hauptteil/Service-Models.png}

	\caption{Die Cloud Service Modelle im Überblick\cite{svc-mod}}

	\centering

\end{figure}

\textbf{Infrastructure as a Service:} Der Nutzer hat die Fähigkeit Rechenleistung, Datenspeicher
 Netzwerke und weitere fundamentale Computing Ressourcen bereitzustellen und beliebige Software
 darauf zu betreiben, dazu können Betriebssysteme und Anwendungen gehören. Die
darunterliegende Infrastruktur wird vom Anbieter betrieben, der Nutzer kann aber
eingeschränkte Kontrolle über bestimmte Komponenten haben, dazu gehören beispielsweise
Firewalls.


\textbf{Platform as a Service:} Der Nutzer verfügt über die Fähigkeit seine eingekaufte oder
selbst erstellten Anwendungen auf der Cloud Infrastruktur zu betreiben, die notwendige
Umgebung die über Sprachen, Bibliotheken, Tools und Services verfügt wird vom Cloud Service Provider (CSP) bereitgestellt. Die darunter liegende Infrastruktur mit Netzwerken, Servern,
Betriebssystemen und Speicher wird vom CSP betrieben, der Nutzer hat die Kontrolle
über Anwendung und Konfiguration der Umgebung in der die Anwendung betrieben wird.


\textbf{Software as a Service:} Dem Nutzer wird der Zugriff auf die vom CSP in der
Cloud Infrastruktur betriebenen Softwareanwendung gewährt. Auf diese wird mithilfe
eines Thin oder Fat Client zugegriffen, dabei kümmert sich der Nutzer nicht um den
Betrieb und die Konfiguration der darunterliegenden Cloud Infrastruktur (Netzwerke, Server, Betriebssystem, Speicher) und die Anwendung selbst mit Ausnahme
eingeschränkter Nutzereinstellungen.\\

In Art der Bereitstellung eines Cloud Services werden vier grundlegende Modelle
unterschieden; es existieren Public, Private, Hybrid und Community Cloud Modelle.\\


\textbf{Private Cloud}: Die Cloud Infrastruktur wird ausschließlich für die Nutzung durch eine einzige
Organisation mit mehreren Nutzern bereitgestellt. Besitz und Betrieb liegen dabei
entweder bei der selben Organisation, einer Drittpartei oder einer Kombination beider, die Infrastruktur kann dabei On- oder Off-Premises\footnote{Hardware ist lokal vor Ort/nicht vor Ort} betrieben werden.

\textbf{Public Cloud}: Die Public Cloud steht für die Nutzung durch die allgemeine Öffentlichkeit bereit.
Die Cloud Infrastruktur befindet sich im Besitz eines Unternehmens, Bildungseinrichtung,
Regierungsorganisation oder einer Kombination aus diesen und wird auch von der selben
 Organisation On-Premises betrieben. 


\textbf{Community Cloud}: Eine Community Cloud wird von einer Gemeinschaft von Nutzern mit gemeinsamen
Anliegen eingesetzt. Der Besitz und Betrieb liegen dabei bei einem oder mehreren
Mitgliedern dieser Gemeinschaft, einer Drittpartei und kann Off- oder On-Premises betrieben

werden.


\textbf{Hybrid Cloud}: Die Hybrid Cloud besteht aus einer Kombination der beschriebenen Modelle (Public, Private und Community). Diese bilden dabei eigene Instanzen die aber durch standardisierte oder proprietäre Schnittstellen den Transfer von Daten und Anwendungen
zwischen den Instanzen erlauben.

\subsection{Vor- und Nachteile des Einsatzes von Cloud Computing}

\subsubsection{Vorteile und Treiber der Adoption von Cloud Computing}

\textbf{Wirtschaftliche Vorteile}: Ein Vorteil in der Nutzung von Cloud Computing
kann darin liegen dass ein Großteil der für den Betrieb notwendigen Infrastruktur
nicht mehr vom Unternehmen selbst eingekauft, eingerichtet und betrieben werden
muss (Abb. 2.1). Potentiell hohe Kosten die bereits vor der
Inbetriebnahme eines Systems mit einem höheren Risiko aufgewendet werden müssen
stellen in Form von individuell geringeren laufenden Beträgen ein deutlich
reduziertes Risiko dar\cite{capex-opex}.\\
Sofern der Einsatz von Cloud Computing in einer sinnvollen und korrekten
Weise erfolgt können je nach Fall die Gesamtkosten um einen hohen Anteil reduziert
werden\cite{total-cost}.\\
Die Gesamtkostenersparnisse stehen auch im Zusammenhang mit Skaleneffekten\footnote{Zusammenhang zwischen produziertem Ertrag und eingesetzter Ressourcen} die für
große Cloud Service Provider gelten. Der Betrieb eines einzelnen Servers ist im Verhältnis
mit bedeutend höheren Kosten verbunden als das hinzufügen eines äquivalenten
Systems zu einem Rechenzentrum im Betrieb von Mircosoft oder einem vergleichbaren
Anbieter\cite{econ-scale}.

\textbf{Skalierbarkeit}: Besonders für schnell wachsende Unternehmen ist die
Möglichkeit schneller Skalierbarkeit einer der prominentesten Vorteile der Cloud.
Es kann nicht nur auf vorhersagbare Anstiege (zum Beispiel ausgelöst durch
eine Verkaufsaktion) sondern auch auf unvorhersehbare Ereignisse reagiert werden.
Zusätzlich ist es möglich diese Skalierung nicht nur bis zu einem bestimmten Limit,
sondern nahezu unendlich zu betreiben. Wichtig ist auch dass sowohl auf steigende
als auch sinkende Nachfrage reagiert werden kann\cite{scale}.

\textbf{Resilienz}: In einem Worst Case-Szenario kann ein ganzes Rechenzentrum
durch unvorhergesehen Ereignisse wie beispielsweise Brände, Naturkatastrophen
oder anderes vollständig zerstört werden. Selbst wenn Backup-Rechenzentren
verfügbar sind ist eine Übertragung der Operationen kein trivialer Ablauf und
birgt oft nicht außer Acht zu lassende Risiken. Die Flexibilität der Cloud
erlaubt es die gesamte Infrastruktur mit sehr geringem Aufwand in nicht
betroffene Regionen zu verlagern und die Kontinuität der Geschäftstätigkeiten
mit minimaler Unterbrechung aufrecht zu erhalten\cite{resil}.

\textbf{Security}: Sicherheitsaspekte können sowohl einen Vor- als auch Nachteil
von Cloud Computing darstellen. Hier sollen zuerst Vorteile dargelegt werden,
potentielle Probleme sind im nächsten Abschnitt beschrieben.\\
Die technischen Möglichkeiten und besonders auch die Wahrnehmung des Themas
Sicherheit in der Cloud unterlagen und unterliegen auch noch immer einem
deutlichen Wandel. Cloud Anbieter investieren
viele Ressourcen in Sicherheit und stellen dem Nutzer zum Beispiel bereits sicher
implementierte Verschlüsselungen zur Verfügung oder bieten einen gewissen
Schutz vor Denial-of-Service Angriffen durch ihre \enquote{natürliche} Skalierbarkeit\cite{sec-1}.

\subsubsection{Herausforderungen und Risiken}

\textbf{Netzwerkabhängigkeit}: Da der Zugriff auf Cloud Dienste über das
Internet erfolgt entsteht dadurch entsprechend auch eine hohe Abhängigkeit. Stabile und schnelle Netzwerkanbindung ist eine kritische Voraussetzung für effektives Arbeiten\cite{net-dep}, bei lokal gehosteten Systemen ist diese Abhängigkeit
entsprechend geringer.

\textbf{Vendor Lock-in}: Bei der Nutzung eines Cloud Anbieters entsteht die
Gefahr sich zu sehr in Abhängigkeit eines einzelnen Anbieters zu begeben.
Im Fall einer Änderung der Nutzungsbedingungen oder einer Änderung im
Kostenmodell die den eignen Interessen stark entgegen steht, besteht die Gefahr
bereits so abhängig von diesem Anbieter zu sein dass die Kosten eines Wechsels
derart hoch ausfallen dass man gezwungen ist die Bedingungen zu akzeptieren\cite{lock-in}.

\textbf{Security und Privacy}: Sicherheitsrisiken sind einer der meistgenannten
Gründe die gegen Cloud Computing sprechen\cite{sec-2}, besonders im Fall der Nutzung einer
Public Cloud. Die Gefahr dass Daten in die Hände dritter gelangen kann zum
beispielsweise nicht vollständig ausgeschlossen werden. Da die Verantwortung über
die Sicherheit der Daten dem Cloud Anbieter unterliegt kann es auch zu Problemen
hinsichtlich Privatheit der Daten kommen, sollte etwa eine Regierungsorganisation
Zugriff auf bestimmte Daten eines Nutzer verlangen könnte dieser ohne dessen
Einverständnis gewährt werden.

\textbf{Kosten}: Auch wenn die Nutzung von Cloud Computing mit dem Vorteil
geringerer Kosten beworben wird, ist dies nicht zwingend garantiert. Werden die
vorhandenen Systeme ungünstig verwendet, bleiben zum Beispiel viele gebuchte
CPUs und IP-Adressen sowie weitere Ressourcen ungenutzt, können unnötig hohe Kosten entstehen. Auch während der Migrationsphase, in der möglicherweise beide Systeme parallel betrieben werden müssen, können höhere Kosten
entstehen als in einem vergleichbaren Zeitraum davor. Nicht zuletzt stellt die Migration komplexer Systeme häufig eine große technische und dadurch auch finanzielle Herausforderung dar\cite{migration-cost}.

\subsection{Überblick über die wichtigsten Cloud Service Provider}

In diesem Abschnitt soll ein knapper Überblick über die wichtigsten Public Cloud Service Provider gegeben werden. Abbildung 2.2 stellt den Marktanteil der aktuell umsatz-stärksten Cloud Service Provider sowie das globale Umsatzwachstum insgesamt dar. Zu beachten ist dass in dieser Abbildung das Service Modell SaaS nicht beinhaltet ist.

\begin{figure}[H]

	\includegraphics[width=1.0\textwidth]{fig/aa-hauptteil/CSP-share.png}
	\caption{CSP Market Share Q2 2021 nach Umsatz\cite{csp-share}}

	\centering

\end{figure}

Aus Abb. 2.2 wir ersichtlich dass Amazon, Microsoft und Google gemeinsam mehr als die Hälfte des Marktes beherrschen, Amazon allein stellt etwa ein Drittel aller Infrastruktur Services bereit.

\begin{figure}[H]

	\includegraphics[width=0.75\textwidth]{fig/aa-hauptteil/Gartner.png}
	\centering
	\caption{CSP Gartner Magic Quadrant Juli 2021\cite{gartner-mag}}

	\centering

\end{figure}

Der Gartner Magic Quadrant für Cloud Service Provider bietet einen groben
Überblick über den Umfang der Angebote (Completeness of Vision) und
die Ausgereiftheit einer Plattform (Ability to Execute). Deutlich erkennbar
ist hier die Vormachtstellung von Amazon gegenüber Microsoft und Google, auffällig ist auch die Stellung von IBM die auf ein mögliches Problem in der Ausgereiftheit der IBM Cloud hinweisen könnte.

\section{Infrastructure as Code}

Automatisierung spielt in der modernen Softwareentwicklung eine wichtige Rolle. Automatisierte Unit- und Integration-Tests gehören inzwischen schon lange zum Standardrepertoire eines Softwareentwicklers. Die Verbreitung der DevOps-Kultur förderte in den letzten Jahren auch die Automatisierung des Build- und Deployment-Prozesses und mit der steigenden Verbreitung Cloud-basierter Software erweitert sich diese Automatisierung nun auch auf das Provisioning der Infrastruktur.

Infrastructure as Code beschreibt im allgemeinen einen Ansatz zur Automatisierung des Infrastruktur-Provisionings basierend auf Methoden aus der
Softwareentwicklung\cite{def-iac}.

Statt eines manuellen Aufbaus und händischer Konfiguration der einzelnen
Komponenten werden maschinenlesbare Dateien verfasst welche dann von einem
IaC Tool eingelesen und verarbeitet werden. Dabei kommen bevorzugt
deklarative Sprachen zum Einsatz deren höhere Abstraktion mehr Flexibilität
als ein imperativer Ansatz erlaubt\cite{dec-imp-iac}.

\subsection{Technologischer Wandel und das Cloud Age Mindset}

Durch die Technologien der Cloud ist es heute möglich eine gewünschte
IT-Infrastruktur sehr viel schneller bereitzustellen als
zuvor. Statt Einkauf, Anschließen und Einrichten eines
physischen Servers das, je nach Szenario einen Zeitraum von mindestens
mehreren Stunden oder Tagen bis hin zu Wochen dauern kann, können
virtuelle Ressourcen in der Cloud in wenigen Minuten verfügbar gemacht werden.
Der schnellere Ablauf wird durch die Automatisierung von Prozessen wie der Bereitstellung der Infrastruktur mithilfe von IaC Tools noch verstärkt. Mit diesen Veränderungen wird das Management und die Erweiterung der
bestehenden Systeme jedoch nicht unbedingt einfacher\cite{iac-schneller}, die Anwendung von
Arbeitsprozesse die sich bisher bewährt haben sind oftmals ineffektiv und verhindern das Ausnutzen des vollen Potentials der Cloud.
Kief Morris, Autor von \textit{Infrastructure as Code - Dynamic Systems for the Cloud Age}, stellt die fundamentalen Unterschiede des Arbeitens mit
Cloud-Technologien mithilfe der folgenden Tabelle (Tab. 2.1) dar.

\begin{table}[H]
	\includegraphics[width=0.9\textwidth]{fig/aa-hauptteil/iron_vs_cloud.png}
	\centering
	\caption{\enquote{Iron vs Cloud Age}\cite{dec-imp-iac}}
	\centering
	
\end{table}

Veränderungen im \enquote{Iron Age} sind aufwändig und teuer und stellen ein
Risiko dar, es wird versucht diese Risikopunkte zu reduzieren, daher werden
viele Veränderung gebündelt getestet und eingeführt wodurch lange
Release-Zyklen entstehen. Die Architekturen die dadurch befördert werden
sind monolytisch, die Konfiguration erfolgt eher mithilfe von GUI-gesteuerten Programmen oder direkter physischer Interaktion, zum Beispiel wenn ein neuer Server
in ein Netzwerk eingebunden wird. Veränderungen in der Cloud stellen
fast genau das Gegenteil dar, daher wird erkennbar dass eine auf das \enquote{Iron Age} zugeschnittene Arbeitsweise für die Cloud nicht effektiv ist.
Ein neues \enquote{Cloud Age Mindset} das die rechte Spalte der Tabelle
verinnerlicht ist erforderlich um die Vorteile der Cloud
wirklich effektiv und in vollem Umfang nutzen zu können.

\subsection{Vorteile von Infrastructure as Code im Vergleich zu manuellem Infrastruktur-Provisioning}

\textbf{Kein Configuration Drift durch einheitliche Codebasis}:
 Configuration Drift bezeichnet eine über die Zeit
wachsende Abweichung zweier ursprünglich identischer Systeme. Wird ein
gleiches System, zum Beispiel ein Applikationsserver, in verschiedenen
Umgebungen eingesetzt stellen diese Umgebungen oftmals auch leicht verschiedene
Anforderungen an diesen Server. Auf diese kann dann mit Optimierungen, etwa in Form spezifischer
Konfigurationsdetails, reagiert werden. Wird nun das ursprüngliche
Basis-System geupdated werden individuelle und oft undokumentierte Anpassungen
nicht berücksichtigt wodurch ein Update unbequeme Konsequenzen nach
sich ziehen kann. Werden alle Veränderungen in einer einheitlichen
Codebasis verwaltet und Updates häufig vorgenommen verhindert man
starken Configuration Drift der ansonsten oftmals stattfindet\cite{conf-drift}.

\textbf{Wiederverwendbarkeit durch einheitlichen Code}:
Ein weiterer Vorteil der durch die Verwendung einer einheitlichen
Codebasis entsteht ist die Wiederverwendbarkeit und Reproduzierbarkeit
eines Systems. Wenn ein identisches System an einer anderen Stelle
aufgebaut werden soll oder geht ein System aus unvorhergesehenen
Gründen in seiner Gesamtheit verloren kann es schnell und mit
verhältnismäßig geringem Aufwand reproduziert werden.
Ein dazu passender Ausdruck in Bezug auf Server ist \enquote{Cattle not Pets}. Statt sich individuell und mit großem Aufwand um einzelne Server zu
kümmern, wie man es etwa mit dem eigenen Haustier tut, sollten Server
wie leicht ersetzbares Vieh behandelt werden\cite{cattle-pets}.

\textbf{Schnelleres Provisioning durch Cloud}: Ein bereits häufig angesprochener Vorteil ist die schnelle Bereitstellung, durch diese Verkürzung bzw. Eliminierung des Hardware-Anschaffungs-Prozesses. Dadurch können sowohl frühe Developer-Builds als auch spätere Release-Versionen schneller getestet und deployed werden wodurch der gesamte Release-Cycle beschleunigt wird.

\textbf{Schnellerer Profit}: Die logische Schlussforderung aus dem vorangegangenen Punkt ist die schnellere Erzielung von Umsätzen. Den Markt als erstes mit einem neuen Produkt zu betreten bringt wirtschaftliche Vorteile mit sich, Voraussetzung dabei ist eine adäquate Qualität welche durch IaC ebenfalls gefördert wird.

\textbf{Einheitlicheres Tooling in Dev, Ops und weiteren Beteiligten Teams}: Verwendung von IaC fördert ein einheitlicheres Tooling in allen Bereichen die mit einem Softwareprodukt in Zusammenhang stehen. Ein einfaches Beispiel hierfür ist die Verwendung eines Source-Code Editors der sowohl für das Schreiben von Programm- und Infrastruktur-Code gleichermaßen notwendig ist.

\textbf{Stärkere Automatisierung im Arbeitsablauf}: Automatisierung bedeutet immer einen gewissen initialen Zusatzaufwand, jedoch kann auf längere Sicht deutlich von automatisierten Abläufen profitiert werden. Testen, Builds und Deployment wurden bereits angesprochen und sind klassische Prozesse deren Automatisierung längerfristig vorteilhaft ist.

\textbf{Höhere Zuverlässigkeit und Sicherheit durch schnelle Updates}: Veränderungen stellen die größte Gefahr für ein Produktionssystem dar, gleichzeitig sind Veränderungen aber unvermeidbar um die Sicherheit des Systems zu gewährleisten und es zu verbessern. Durch die Fähigkeit Veränderungen schnell und dennoch zuverlässig durchzuführen wird die Reaktionszeit auf unvorhergesehene Ereignisse und Anforderungen wesentlich verkürzt\cite{opt-change}.

\textbf{Schnellere Fehlersuche und -behebung}: Potentielle Fehler können durch Automatisierung und Modularität (siehe. Kapitel 2.2.4) schneller isoliert, gefunden und behoben werden. Infolgedessen profitieren Sicherheit und Stabilität von einer Struktur die eine einfache und schnelle Integration von Veränderungen fördert.

\subsection{Herausforderungen und Argumente gegen den Einsatz von Infrastructure as Code}

Kief Morris benennt drei Argumente die gegen die Einführung von IaC
genannt werden, diese sollen hier Im Kontext der zuvor genannten Vorteile betrachtet
werden.

\textbf{1. \enquote{Veränderugen werden nicht oft genug durchgeführt um
Automatisierung zu rechtfertigen.}}

Die Idee dass ein System einmal erstellt und dann \enquote{fertig} ist wodurch eine
Automatisierung der Veränderungen überflüssig wird entspricht sehr selten der tatsächlichen Realität.
IT-Systeme und damit auch IT-Infrastruktur wird während ihres gesamten
Lebenszyklus mehr oder weniger kontinuierlich verändert und erweitert.\\Sicherheitslücken in alten Versionen von Softwarepackages oder
Betriebssystemen sind keine Seltenheit und müssen gepatcht werden um
einen sicheren und Zuverlässig Betrieb zu gewährleisten. Neue Features in bestehender Software kann neue Infrastruktur, zum Beispiel in Form einer zusätzlichen Datenbank, notwendig machen oder eine veränderte Konfiguration
erfordern. Gerade bei Sicherheitslücken
ist es wichtig Anpassungen nicht erst nach längerer Zeit sondern so
schnell wie möglich durchzuführen um Sicherheit und Stabilität nicht
zu gefährden. Ein weiteres Szenario das die Stabilität eines Systems
gefährden kann ist ein schneller Zuwachs an Last die ein System erfährt,
können die Kapazitäten automatisiert erweitert werden wird ein Zusammenbruch des Services auf einfache Art verhindert\cite{opt-change}.

\enquote{A fundamental truth of the Cloud Age is: Stablity comes from making changes.}\cite{stab-cloud}

Eine fundamentale Wahrheit des Cloud Zeitalters ist: Stabilität entsteht durch
Veränderung.

\textbf{2. \enquote{Infrastruktur soll zuerst aufgebaut, danach automatisiert werden.}}

Die Umsetzung von Infrastructure as Code stellt eine durchaus eine große Herausforderung dar, umso mehr wenn die entsprechenden Kompetenzen noch aufgebaut werden müssen. Der Nutzen wird deshalb nicht unbedingt direkt ersichtlich wodurch es zu Situationen kommt in denen es attraktiv erscheint Infrastruktur zuerst aufzubauen und sich erst später um die Automatisierung zu kümmern. Mit diesem
Ansatz werden viele der Vorteile von IaC jedoch verwirkt. Ein bestehendes, komplexes Infrastruktur-System zu automatisieren ist eine deutlich größere Herausforderung als ein System von Grund auf mit dem Gedanken an Automatisierung aufzubauen\cite{build-auto}.

\textbf{3. \enquote{Es muss zwischen schneller Umsetzung und hoher Qualität
gewählt werden.}}

Die Idee dass der Fokus auf hohe Geschwindigkeit und hohe Qualität
sich gegenseitig behindert oder ausschließt mag logisch erscheinen,
in der Praxis ist dies jedoch nicht der Fall.
Ein unausgeglichener Fokus auf eines der beiden Kriterien führt im Lauf der Zeit zu einem \enquote{Fragile Mess} (Abb. 2.4).

\begin{figure}[H]

	\includegraphics[width=1.0\textwidth]{fig/aa-hauptteil/Speed_vs_Quality.png}

	\caption{Verhältnis von Geschwindigkeit und Qualität\cite{speed-quality}}

	\centering

\end{figure}


Wird Geschwindigkeit über Qualität gestellt (Quadrant links oben) entstehen
mit der Zeit chaotische und instabile Systeme an denen Veränderungen mit
der Zeit nur noch erschwert und deshalb langsam durchgeführt werden können.\\Wird Geschwindigkeit zu niedrig priorisiert (Quadrant rechts unten) führt es allerdings auch dazu
dass letzten Endes durch Druck von Deadlines und schnellen Workarounds
technische Schulden aufgebaut werden die ebenfalls zu einem qualitativ
schlechten System führen.\\ Aufgrund dieser Probleme ist es wichtig Geschwindigkeit und Qualität
gleichermaßen zu priorisieren.

\subsection{Die drei Kernverfahren von Infrastructure as Code}

\begin{itemize} 

	\item \textbf{Define everything as Code}: Alle Teile eines System
in Form von Code zu definieren bringt mehrere Vorteile mit sich. Der Konfigurations-Code kann mehrfach ausgeführt werden, daher ist ein als Code definiertes System wiederverwendbar. Es können unkompliziert mehrere
identische Instanzen erstellt werden, das gilt auch für den Fall
wenn Fehler auftreten und ein Neuaufbau erforderlich ist.
Das Verhalten des Systems ist vorhersehbarer, fortlaufendes automatisches
Testen ist möglich und damit auch zuverlässiger.
Definition in Code macht auch den Aufbau eines Systems transparenter,
da dieser immer dem tatsächlichen Zustand entspricht und
diesen damit auch dokumentiert\cite{coreprinc-1}.
	
	\item \textbf{Continuously Test and Deliver All Work in Progress}: 
Fortlaufendes, automatisiertes Testen und Integrieren aller Komponenten
die sich in Entwicklung befinden dient dem Ziel die Qualität eines
Systems nicht nur \enquote{einzutesten} sondern von Beginn an und kontinuierlich
einzubauen\cite{coreprinc-1}.
	
	\item \textbf{Build Small, Simple Pieces That You Can Change Independently}: Systeme die aus mehreren kleineren voneinander unabhängigen Komponenten
bestehen sind generell stabiler als große Monolithen. Eine Änderung die
einen Fehler verursacht betrifft nur die Komponente in der die Änderung
stattfindet, diese kann dann leichter isoliert und das Problem behoben
werden. Kleine Komponenten sind in der Regel auch weniger Komplex und
dadurch leichter zu verstehen. Ein einzelner Fehler nach einem Update
hat auch den Vorteil dass nur diese Komponente und nicht das gesamte System auf eine ältere Version zurückgesetzt werden muss um
den Betrieb wieder herzustellen\cite{coreprinc-2}.

\end{itemize}

\section{Funktionsprinzip und Rolle von Terraform im IaC-Anwendungsprozess}

Während der Anwendung von Infrastructure as Code kann primär zwischen zwei wichtigen Phasen unterschieden werden, einer initialen Einrichtungsphase und der darauf folgenden Wartungs- und Betriebsphase. Während der Einrichtung wird die Infrastruktur bereitgestellt und konfiguriert, genauso wird auch Software installiert und eingerichtet. Nachdem das System dann in Betrieb genommen wurde können Anpassung notwendig sein, Server werden hinzugefügt und abgebaut, Software wird aktualisiert und neu konfiguriert.

\subsection{Überblick über Infrastructure as Code Tools}

Infrastructre as Code beinhaltet verschiedene konkrete Anwendungsfälle und
entsprechend existieren auch Tools die zum Teil ein breiteres Spektrum
von IaC abdecken, zum Teil aber auch eher spezialisiert sind; Terraform
ist dabei eher ein Beispiel eines spezialisierten Tools. Die unten stehende
Abbildung 2.5 soll einen Überblick über verschiedene IaC Tools und deren Aufgabengebiete
verschaffen, die Einordnungen sind dabei aber nicht unbedingt als absolut
anzusehen. Es ist zum Beispiel möglich innerhalb eines Terraform-Deployments
auch Software zu installieren und zu konfigurieren, allerdings wird die
tatsächliche Installation dann eher per von Terraform aufgerufenen Skripten
vorgenommen statt von Terraform selbst verwaltet zu werden, daher ist
Terraform hier ausschließlich als Infrastruktur-Management Tool eingeordnet.


\begin{figure}[H]

	\includegraphics[width=1.0\textwidth]{fig/aa-hauptteil/IaC_Tools.png}

	\caption{Überblick IaC Tools\cite{iac-tools}}
	\centering

\end{figure}

\subsubsection{Vorteile und Limiterungen von Terraform}

Da sich diese Arbeit primär mit dem Provisioning von grundlegender Cloud
Computing Infrastruktur in Form von VM's, Netzwerken, Datenspeicher und
anderen grundlegenden Komponenten beschäftigen soll bietet sich der Einsatz
eines darauf spezialisierten Tools an. Neben Terraform existiert in diesem Bereich auch das Tool Pulumi, in dieser Arbeit wird Terraform jedoch aus den folgenden Gründen verwendet:

\begin{itemize}

	\item \textbf{Modularität}: Terraform Module erlauben es ein System in
mehrere klar definierte Komponenten zu strukturieren. Dadurch wird die
Wiederverwendbarkeit dieser ermöglicht und gefördert, die daraus resultierenden Vorteile wurden bereits in den vorangegangenen
Kapiteln angesprochen.\\Pulumi strukturiert Infrastruktur Code entweder in einem großen
monolithischen Projekt oder vielen kleinen Mikroprojekten, beide
Optionen sind weniger flexibel und umständlicher als die von Terraform implementierte Lösung.
	
	\item \textbf{Weitere Verbreitung und größere Popularität}: Terraform wurde
2014, Pulumi 2017 veröffentlicht, entsprechend ist Terraform deutlich weiter
verbreitet und verfügt über all die Vorteile die eine größere Community mit
sich bringt. Dazu gehören mehr Lernressourcen, mehr Codebeispiele, größere
Bekanntheit und mehr Jobs für die Arbeit mit Terraform.
	
	\item \textbf{Dokumentation}: Einen weiteren Voteil von Terraform stellt
dessen umfangreiche und ausgereifte Dokumentation sowie auch die
Dokumentation der einzelnen Provider dar. Der genaue Aufbau der einzelnen
Ressourcen wie etwa einer VM auf Google Cloud Platform
(google\_compute\_instance) ist mit einem Beispiel und der zugehörigen
Argument Reference versehen aus der direkt ersichtlich wird welche
Argumente notwendig (required), was der Zweck jedes einzelnen Arguments ist
und wo anstelle eines einfachen Wertes ein Block oder eine Liste erwartet wird.

\end{itemize}

\subsection{Funktionsweise von Terraform}

Terraform ist ein Infrastructure as Code Tool das es ermöglicht Infrastruktur
sicher und effizient aufzubauen, zu verändern und zu versionieren. Die Funktionsweise von Terraform wird in Abbildung 2.6 dargestellt.

\begin{figure}[H]

	\includegraphics[keepaspectratio, height=15cm]{fig/aa-hauptteil/Terraform.png}

	\caption{Terraform Funktionsprinzip\cite{tf-princ}}

	\centering

\end{figure}


Terraform verwendet eine deklarative Domänenspezifische Sprache (DSL) die es erlaubt Infrastruktur in Konfigurationsdateien zu beschreiben die
versioniert, geteilt und wiederverwendet werden können. Terraform Module können auf einer Public Module Registry \footnote{Vergleichbar mit der npm-Registry von Nodejs} zur allgemeinen Verfügung bereitgestellt und von der breiteren Terraform-Community wiederverwendet werden. Terraform unterstützt über Plug-Ins, die Terraform Provider, ein große Anzahl an Plattformen.

\subsubsection{Terraform State}

Das Terraform State-File ist die wichtigste Datei in einem Terraform-Projekt. Sie enthält die Informationen der aktuell existierenden und von Terraform verwalteten Ressourcen und stellt ein Mapping zwischen den Konfigurationsdateien und der realen Welt dar\cite{tf-state}. Zusätzlich befinden sich essentielle Metadaten und Informationen über die Abhängigkeiten der verschiedenen Ressourcen im Terraform State.

Der Terraform State kann entweder lokal oder in einem Remote Backend, zum Beispiel der Terraform Cloud, gespeichert werden. Lokaler State ist ausreichend für ein kleineres Forschungsprojekt eines einzelnen Entwicklers, für wichtige Projekte und die Kollaboration in einem Team sollte jedoch ein Remote Backend gewählt werden. Sollten zwei Entwickler gleichzeitig Änderungen an der Infrastruktur vornehmen wollen muss ausgeschlossen werden dass der State korrumpiert und inkonsistent wird. Sobald der erste Anpassungsvorgang begonnen wird, wird der Zugriff auf den State gesperrt und erst am Ende wieder freigegeben, auf diese Weise bleibt der State konsistent.

\subsubsection{Terraform Workflow}

Der grundlegende Terraform Workflow wird in Abbildung 2.7 dargestellt. Er besteht primär aus vier Befehlen: einem Init-Befehl zur Initialisierung des Projekts, der Erstellung des Execution Plan, Durchführung des Execution Plan und einem Destroy-Befehl zur Freigabe/Abbau aller von Terraform verwalteten Ressourcen.

\begin{figure}[H]	
	\includegraphics[keepaspectratio, width=\textwidth/2]{fig/aa-hauptteil/init-plan-apply-destroy.png}
	\centering
	\caption{Terraform Workflow\cite{tf-workflow}}	
	\centering	
\end{figure}

Mit \textbf{\texttt{terraform init}} wird das Arbeitsverzeichnis initialisiert, die Provider und Module installiert sowie das Backend für den Terraform State konfiguriert.

Durch \textbf{\texttt{terraform plan}} wird der Execution Plan erstellt. Der Execution Plan definiert alle Schritte die von Terraform durchgeführt werden um vom aktuellen Zustand, gespeichert im Terraform State, zum in den Konfigurationsdateien mit Terraform Code beschriebenen Zustand zu gelangen. Dieser Execution Plan kann ausgegeben und manuell reviewt werden bevor die tatsächliche Ausführung dessen vorgenommen wird. Durch die Erstellung dieses Plans werden Abhängigkeiten betrachtet die die Reihenfolge der Ressourcen-Erstellung bestimmen, voneinander unabhängige Ressourcen können zum Beispiel parallel erstellt werden.

Die Ausführung des Execution Plan wird durch \textbf{\texttt{terraform apply}} ausgeführt. Es gibt zwei Modi: Der \textbf{Automatic Plan Mode} erstellt automatisch einen neuen Execution Plan, der \textbf{Saved Plan Mode} verwendet einen in einer Datei gespeicherten Execution Plan.

Und zuletzt dient \textbf{\texttt{terraform destroy}} dazu alle in Terraform verwalteten Ressourcen zu \enquote{zerstören} und damit wieder freizugeben. Dies wird in einem Produktionssystem selten Anwendung finden, während der Entwicklung und für Testprojekte ist dies jedoch extrem nützlich.

\subsection{Einführung in die Hashicorp Configuration Language}

Die von Terraform verwendete Konfigurationssprache wurde mit dem Ziel
entwickelt einen Kompromiss zwischen Maschinenfreundlichkeit und
Menschenlesbarkeit zu erzielen\cite{hcl}. Existierende Serialisierungsformate,
Konfigurationssprachen und Programmiersprachen konnten die Ziele
der Terraform-Entwickler nicht erfüllen daher kommt nun bei Terraform
eine DSL in Form der Hashicorp Configuration Language (HCL) zum Einsatz.

\subsubsection{Grundlegende Elemente}

HCL besteht aus drei grundlegenden Elementen: Blöcken (Blocks), Argumenten
(Arguments) und Ausdrücken (Expressions).


\begin{lstlisting}[caption={Grundlegende Elemente von HCL},captionpos=b]
blockType "label1" "label2" {
	...
	/*This is a block*/
	...
	
	argument = 5
	
	arguments + can + build = expressions
}
\end{lstlisting}

\textbf{Blöcke} stellen für gewöhnlich ein Objekt, im Fall von
Infrastruktur-Code meistens eine Computing Ressource, dar.
Blöcke besitzen einen Typ und Null bis mehrere Label. Blöcke beinhalten
Argumente und weitere verschachtelte Blöcke.\\
\textbf{Argumente} sind das was in den meisten Programmiersprachen die
Variablen darstellen: Ein Wert der einem Namen zugewiesen wird.\\
\textbf{Ausdrücke} sind ähnlich wie in anderen Sprachen ein aus anderen
Ausdrücken und Argumenten berechneter Wert, ein Argument ist in diesem Sinne
die simpelste Form eines Ausdrucks.


\subsubsection{Input und Output-Variablen}


Input-Variablen sind nützlich um Parameter außerhalb des eigentlichen
Terraform Codes anzupassen. Die ID des Projektes stellt einen solchen
Parameter dar, befindet sich diese außerhalb des Codes muss nur die Datei
welche die Input-Variablen enthält angepasst werden, alles andere kann ohne
Veränderungen wiederverwendet werden.


\begin{lstlisting}[caption={Beispiel Input-Variable},captionpos=b]
variable "project" {
	default = "some_value"
	description = "a description"
}
\end{lstlisting}

Input-Variablen können entweder während der Ausführung über die Kommandozeile oder über eine Datei mit einfachen Key-Value Paaren befüllt werden.

Output-Variablen werden in der Regel verwendet um nach dem Aufbau des Systems auf spezifische Parameter einfachen und schnellen Zugriff zu ermöglichen.

\begin{lstlisting}[caption={Beispiel Output-Variable},captionpos=b]
output "something_important" {
	value = resource-group.vm-name.ip-address
}
\end{lstlisting}

Werte wie die IP einer Virtuellen Maschine auf einer Public Cloud sind oft vor der Bereitstellung dieser nicht bekannt und können erst danach ausgegeben werden. Terraform kann Output-Variablen mithilfe eines Kommandos schnell und übersichtlich ausgeben.


\subsubsection{Terraform Module}

Die Verwendung von Modulen gestaltet sich ebenfalls relativ einfach. Es wird immer eine Quelle benötigt aus der das Modul bezogen wird, diese kann ein lokales Verzeichnis oder eine Module Registry sein. Zusätzlich benötigen die meisten Module eine Reihe von Input-Variablen wie im folgenden Listing 2.4 dargestellt.

\begin{lstlisting}[caption={Beispiel Terraform Module},captionpos=b]
module "showcase_kubernetes" {
	source = "./showcase_kubernetes"
	
	project   = var.project
	network   = google_compute_network.jsa-vpc_network.name
	zone      = var.zone
	num_nodes = 2
}
\end{lstlisting}

\subsubsection{Terraform Provider Konfiguration}

Terraform Provider benötigen ähnlich wie Module eine Quelle und eine optionale zusätzliche Konfiguration. In Listing 2.6 wird beispielhaft der Google Cloud Platform Provider eingebunden und für ein spezifisches Projekt konfiguriert.

\begin{lstlisting}[caption={Beispiel Terraform Provider Konfiguration},captionpos=b]
terraform {
	required_providers {
		google = {
			source  = "hashicorp/google"
			version = "4.1.0"
		}
	}
	
	provider "google" {^
		project = "active-woodland-324808"
		region  = "europe-west3"
		zone    = "europe-west3-b"
	}
}
\end{lstlisting}

\chapter{Evaluierungsanforderungen und Umsetzung}
\label{sec:ergeb}

\section{Evaluierungsanforderungen}

\subsection{Ziel der Evaluierung}

Das Ziel dieser Evaluierung ist es einen Vergleich zwischen den beiden Cloud Plattformen Google Cloud Platform un Microsoft Azure auf Basis von deren Unterstützung von Infrastructure as Code mit Terraform durchzuführen. Anhand der Ergebnisse sollen auch die Vorteile von Infrastructure as Code gegenüber manuellem Provisioning deutlich werden.

\subsection{Untersuchte Komponenten der Terraform Provider}

Zu diesem Zweck wird ein Beispielszenario, bestehend aus einem Kubernetes Cluster und einem Datenbankserver, für beide Plattformen in Terraform Code implementiert und auf den entsprechenden deployed. Zusätzlich wird im Vorfeld manuell eine Container Registry auf den beiden Plattformen erstellt und ein Image auf dieser bereitgestellt. Diese Container Registry soll dann als Terraform Data Source im Projekt eingebunden und das darauf liegende Image via Terraform auf dem Kubernetes Cluster deployed werden.\\
Die Struktur, bestehend aus Datenbankserver und Kubernetes Cluster, ist eine einfache Repräsentation einer Infrastruktur die für den Betrieb moderner Cloud basierter Anwendungen notwendig ist.

\subsection{Limitierungen der Untersuchung}

Primär soll damit die grundlegende Eignung der Plattform für dieses Szenario untersucht werden. Spezialisiertere Szeanrien werden durch diesen Vergleich nicht repräsentiert, ebenso wird die Security des Infrastruktur-Systems nur in einer minimal erforderlichen Weise umgesetzt da sich Anforderungen an diese je nach Organisation und Anwendung stark unterscheiden können.\\
Weiterhin findet das Deployment des Beispielszenarios nur in einer einzelnen Availability Zone der jeweiligen Plattformen statt. Im Fall von GCP ist dies die Zone \enquote{europe-west3-b} und bei Microsoft \enquote{westeurope}.

\subsection{Auswahl der Evaluierungskriterien}

Das Softwarequalitätsmodell der ISO 25010 wird als ein Grundstein für die
Evaluierung von Software beschrieben\cite{iso-25010}. Da die Terraform Provider statt einer ganzheitliche Software nur Plug-Ins
und damit eine kleinere Komponente von Terraform darstellen kann nicht
jeder der in der ISO 25010 aufgelistet Punkte sinnvoll angewendet werden.
Einige Bereiche, zum Beispiel der Bereich Security mit all seinen
untergeordneten Themen, benötigen eine deutlich genauere Betrachtung als
es im Rahmen dieser Arbeit möglich ist um ein sinnvolles und vollständiges
Ergebnis gewährleisten zu können.\\
Aus diesem Grund sollen nur ein kleinerer Teil der aufgeführten Merkmale
betrachtet werden, interessant sind vor allem solche die eine schnelle
Einführung von Terraform in den Entwicklungsprozess beeinflussen.
Ebenfalls interessant sind die Flexibilität und Wartbarkeit da
insbesondere letztere einen der großen Vorteile darstellt den man durch
den Einsatz von Infrastructure as Code Tools- und Prinzipien erzielen kann.


\begin{figure}[H]

	\includegraphics[keepaspectratio, height=4.5cm]{fig/aa-hauptteil/ISO25010.png}

	\caption{Überblick ISO 25010}

	\centering

\end{figure}


Im Folgenden sollen die einzelnen Merkmale der ISO 25010 kurz
zusammengefasst und erläutert werden ob diese in der Evaluierung
der Terraform Provider von Azure und Google Cloud Platform sinnvoll betrachtet werden können.

\subsubsection{Functional Suitability}


\begin{itemize}

	\item \textbf{Functional Completeness}: Die Vollständigkeit mit welcher
die Aufgaben und Ziele die vom Nutzer an die Software gestellt werden
erfüllt werden können.

	
	Anwendbarkeit: Eine zufriedenstellende Functional Completeness ist die
grundlegende Voraussetzung für den Einsatz jeder Software, dies gilt
auch für den Einsatz von Terraform und die zu untersuchenden Provider.

	
	\item \textbf{Functional Correctness}: Grad zu welchem die Software
korrekte Ergebnisse mit einer ausreichenden Genauigkeit liefert.

	
	Anwendbarkeit: Da im Falle der Bereitstellung von Infrastruktur durch
deklarativen Code wenig Spielraum zulässt und im Fall der hier
untersuchten Systeme lediglich ein \enquote{richtig} oder

	\enquote{falsch} zulässt spielt dieser Punkt keine Rolle.

	
	\item \textbf{Functional Appropriateness}: Grad zu welchem die

	Funktionalitäten der Software die Erfüllung der Aufgaben ermöglichen
und unterstützen.

	
	Anwendbarkeit: Da die Terraform Provider im Prinzip nur eine
Schnittstelle zu den jeweiligen Plattformen darstellen ist dieser Aspekt
hier wenig relevant. Bei einer allgemeinen Betrachtung der
Funktionalität von Terraform wäre dieser Punkt jedoch sehr interessant.

\end{itemize}


\subsubsection{Performance Efficiency}


\begin{itemize}

	\item \textbf{Time Behaviour}: Grad zu welchem die Anforderungen an
Bearbeitungszeit und Durchsatz erfüllt werden.

	
	Anwendbarkeit: Die Dauer in welcher ein System von der Plattform durch
den jeweiligen Terraform Provider bereitgestellt werden kann ist ein
relevanter Aspekt der sehr gut untersucht und verglichen werden kann.

	
	\item \textbf{Resource Utilization}: Beschreibt Umfang und Typ der
Ressourcen die von der Software während des Betriebs benötigt werden.

	
	Anwendbarkeit: Da die Terraform Provider selbst nur die
Schnittstelle darstellen ist dieser Aspekt nicht sinnvoll anwendbar.
Bei einem
Vergleich verschiedener Softwaretools wäre dieser Aspekt von größerer
Bedeutung.

	
	\item \textbf{Capacity}: Grad zu welchem die maximalen Limits der
Software die Anforderungen erfüllen.

	
	Anwendbarkeit: Auch dieser Aspekt ist nicht relevant, es trifft die
die selbe Argumentation wie beim vorhergehenden Punkt zu.

\end{itemize}


\subsubsection{Compatibility}


\begin{itemize}

	\item \textbf{Co-Existence}: Grad zu welchem die Software ihre Funktion
erfüllen kann während sie sich eine Umgebung mit anderen Programmen
teilt ohne deren Funktionalität zu beeinträchtigen.

	
	Anwendbarkeit: Da in diesem Bereich im Rahmen der Arbeit mit wenigen
Providern keine Probleme zu erwarten sind wird dieses Thema nicht
explizit betrachtet.

	
	\item \textbf{Interoperability}: Grad zu welchem die Software mit
anderen Produkten Informationen austauschen und verarbeiten kann.

	
	Anwendbarkeit: Im Rahmen der Arbeit wird die Interaktion zwischen
den Providern von Google Coud Platform und Microsoft Azure mit
Kubernetes und Helm betrachtet.

\end{itemize}


\subsubsection{Usability}


\begin{itemize}

	\item \textbf{Appropriateness Recognizability}: Beschreibt wie einfach
ein Nutzer erkennen kann ob die Software eine angemessene Lösung für
dessen Anwendungsfall darstellt.

	
	Anwendbarkeit: Dieser Aspekt kann zu einem gewissen Grad betrachtet
und bewertet werden. Die Bezeichnungen der verschiedenen Computing 
Ressourcen können zum Beispiel ihre Funktion gut oder auch weniger
genau beschreiben.

	
	\item \textbf{Learnability}: Grad zu welchem ein bestimmter User
bestimmte Lernziele in einem definierten Kontext erreichen kann.

	
	Anwendbarkeit: Eine Untersuchung der Erlernbarkeit eines Terraform Providers könnte durchaus vorgenommen werden. Um ein aussagekräftiges
Ergebnis erzielen zu können wären jedoch umfangreichere Untersuchungen
mit mehreren Usern notwendig weshalb im Rahmen dieser Arbeit dieses
Kriterium nicht betrachtet werden soll.

	
	\item \textbf{Operability}: Beschreibt Attribute die ein System besitzt
das dessen Bedienung vereinfacht.

	
	Anwendbarkeit: Bei einer Betrachtung von Terraform als ganzes könnte
dieser Punkt sinnvoll untersucht werden, die einzelnen Provider
unterscheiden sich hier jedoch nicht.

	
	\item \textbf{User Error Protection}: Grad zu dem die Software den
Nutzer gegen eigene Fehler (z.Bsp. während der Eingabe) schützt.

	
	Anwendbarkeit: Hier liegt die selbe Lage wie beim vorhergehenden
Punkt vor, wird daher nicht betrachtet.

	
	\item \textbf{User Interface Aesthetics}: Beschreibt wie ansprechend
und zufriedenstellend das Userinterface bewertet werden kann.

	
	Anwendbarkeit: Dieser Aspekt ist irrelevant da die Terraform Provider
nicht direkt verwendet werden und kein User interface besitzen.
Terraform selbst wird aus der Kommandozeile heraus bedient.

	
	\item \textbf{Accessibility}: Grad zu welchem die Software von
verschiedenen Nutzern mit verschiedenen Fähigkeiten und Charakteristiken
verwendet werden kann.

	
	Anwendbarkeit: Für den Vergleich der Provider nicht anwendbar. Die 
selbe Argumentation wie bei Operability und User error protection
treffen auch hier zu. 

\end{itemize}


\subsubsection{Reliability}


\begin{itemize}

	\item \textbf{Maturity}: Beschreibt wie zuverlässig die Software unter
normalen Bedingungen arbeitet.

	
	Anwendbarkeit: Durch den begrenzten Umfang der in dieser Thesis
durchgeführten Arbeiten kann dieser Aspekt nur begrenzt betrachtet
werden. Sollten Auffälligkeiten in diesem Bereich auftreten werden
diese jedoch erfasst und dokumentiert.

	
	\item \textbf{Availability}: Beschreibt ob die Software betriebsbereit
und verfügbar ist.

	
	Anwendbarkeit: Da die Terraform Provider nur ein Plug-In darstellen
hängt dieser Aspekt sowohl von Terraform und den Cloud Plattformen ab,
nicht von den Providern selbst.

	
	\item \textbf{Fault Tolerance}: Grad zu welchem die Software trotz
Hard- und Softwarefehlern ihre Funktion erfüllen kann.

	
	Anwendbarkeit: Auch dieses Kriterium ist beim Vergleich zwischen den
Providern nicht von Bedeutung da die Funktionalität nicht von diesen
abhängt.

	
	\item \textbf{Recoverability}: Grad zu welchem die Software bei einiger
Unterbrechung oder einem Fehler betroffene Daten wiederherstellen und
die Funktionalität wiederherstellen kann.

	
	Anwendbarkeit: Hier kann untersucht werden ob Terraform bei
den verschiedenen Providern unterschiedlich auf einen Abbruch der 
Internetverbindung oder bei einer fehlerhaften Eingabe reagiert.

	
\end{itemize}


\subsubsection{Security}


Das Thema Security beinhaltet die Merkmale Confidentiality, Integrity,
Non-repudiation, Accountability und Authenticity. Auf die
Sicherheit von Terraform und den jeweiligen Coud Plattformen soll
aufgrund des Umfangs und der Komplexität des Themas im Rahmen dieser
Arbeit nicht eingegangen werden. Für einen Vergleich der Terraform
Provider selbst ist das Thema ohnehin weniger von Interesse da die
Sicherheit stärker von Terraform selbst und den einzelnen Cloud
Plattformen abhängt als von den individuellen Providern. 


\subsubsection{Maintainability}


\begin{itemize}

	\item \textbf{Modularity}: Beschreibt den Grad zu welchem ein System voneinander unabhängigen Komponenten aufgebaut ist.

	
	Anwendbarkeit: Dieser Aspekt wird von Terraform selbst implementiert
und spielt bei der Betrachtung verschiedener Provider keine Rolle.
Interessant wäre jedoch ein Vergleich zwischen Terraform und anderen
IaC Tools welcher im Rahmen dieser Arbeit jedoch nicht vorgenommen wird.

	
	\item \textbf{Reusability}: Beschreibt wie gut sich Komponenten in
anderen Systemen und Komponenten wiederverwenden lassen.

	
	Anwendbarkeit: Auch dieser Aspekt ist für den Vergleich nicht
relevant, die Argumentation ist die selbe wie für das Thema Modularity.
Für einen Vergleich mit anderen Tools wäre dies ein sehr relevantes
Thema da Terraform sehr gute Optionen besitzt um das Schreiben
modularen Codes zu fördern. 

	
	\item \textbf{Analysability}: Grad der Effektivität und Effizienz mit
der der Einfluss auf das System ermittelt werden kann der durch eine
Veränderung verursacht wird. Dazu gehört auch das Ermitteln von 
Komponenten die verändert werden sollen sowie das diagnostizieren von
Fehlern und Schwächen des Produkts.

	
	Anwendbarkeit: Analysability ist ein Aspekt der sowohl
von Terraform selbst als auch von der Cloud Plattform abhängt. Dieses
Thema soll im Rahmen des Vergleichs nicht betrachtet werden da
es zu großen Teilen nicht vom Provider abhängt.

	
	\item \textbf{Modifiability}: Beschreibt wie gut ein System verändert
werden kann ohne Fehler aufzuwerfen oder die Qualität zu verschlechtern.

	
	Anwendbarkeit: Hier kann untersucht werden ob es im Fall der
Modifizierung von einzelnen Ressourcen Unterschiede gibt. Es kann
untersucht werden ob bei den Plattformen Ressourcen bei einer
vergleichbaren Modifikation gelöscht und neu erstellt werden oder
ob ein stoppen, verändern und neu starten ausreicht bzw. die
Eigenschaft im laufenden Betrieb mit minimaler Unterbrechung des
Services verändert werden kann. 

	
	\item \textbf{Testability}: Effektivität und Effizienz mit der
Testkriterien etabliert werden und entsprechende Tests durchgeführt
werden können.

	
	Anwendbarkeit: Im Vergleich der Provider ist das Thema Testen
weitgehend irrelevant. Sehr interessant wäre jedoch wieder der Vergleich
mit anderen vergleichbaren Tools, Terraform selbst beinhaltet
wenig bis keine Möglichkeiten für Test und setzt mehr auf zusätzliche
Tools und Frameworks.

\end{itemize}


\subsubsection{Portability}


Portability fasst die Aspekte Adaptability, Installability und
Replaceability zusammen. Bei einem Vergleich der Terraform Provider
können diese Aspekte nicht sinnvoll miteinander verglichen werden da
diese von Terraform selbst und nicht von den Providern abhängen.



\subsubsection{Zusammenfassung der für den Vergleich ausgewählten Aspekte}


Für den im Rahmen dieser Arbeit durchgeführten Vergleich werden nur
einige der in der ISO 25010 definierten Qualitätsmerkmale betrachtet.
Da die Terraform Provider nur einen Teil der gesamten Software ausmachen
sind zahlreiche Aspekte kaum oder gar nicht von den Terraform Providern
abhängig und werden aus diesem Grund nicht betrachtet, andere Themen
sind zu umfangreich und/oder komplex um hier zufriedenstellend
bewertet werden zu können.\\
Kurz zusammengefasst werden die folgenden Merkmale betrachtet:


\begin{itemize}

	\item \textbf{Functional completeness}

	\item \textbf{Time behaviour}

	\item \textbf{Recoverability}

	\item \textbf{Modifiability}

\end{itemize}



\section{Umsetzung des Testsystems}

\subsection{Eingesetzte Software und Tools}

In diesem Abschnitt sollen die Tools die bei der Umsetzung zum Einsatz
kommen knapp zusammengefasst werden.


Als Source-Code Editor kommt Visual Studio Code zum Einsatz.\\
Die Versionierung des Sourcecodes erfolgt durch ein privates
Git-Repository auf Github.\\
Zeitmessungen werden mit dem Bash Kommando \texttt{time <command>} durchgeführt und das Ergebnis der Zeile \texttt{real} verwendet.\\


\subsection{High-Level Aufbau des Testsystems}

Als primäres Testobjekt dient ein Infrastruktursystem das typische Anwendungsfälle
repräsentieren soll. Es besteht aus Netzwerk, mehreren Datenbanken und 
einem Kubernetes Cluster mit mehreren Worker Nodes. Das System ist eine
leicht veränderte Variante des öffentlich einsehbaren
Infrastruktur-Showcase der Novatec.\\
Weiterhin existiert ein bereits manuell erstellter Object Storage mithilfe
dessen auf einer ebenfalls manuell erstellten Container Registry das
Dockerimage für den Kubernetes Cluster bereitgestellt wird. Dieses Image
bzw. die Registry wird dann im Terraform Projekt als Data Source erfasst.\\
Ergänzend zu diesem System sollen 
zusätzlich einige Tests mit einzelnen Ressourcen wie zum Beispiel
Virtuellen Maschinen durchgeführt werden.


Der originale Infrastruktur-Showcase besteht aufgrund der verhältnismäßig
geringen Größe und Komplexität aus einem einzelnen Terraform Modul
"Platform" das die gesamte Infrastruktur enthält. Für diese Arbeit wurden
die Kubernetes- und Datenbank-Komponenten zu Demonstrationszwecken in
jeweils eigene Module ausgelagert. Diese Module könnten in
eine öffentliche oder auch private Terraform Module Registry
hochgeladen werden um später in weiteren Projekten verwendet werden zu
können.


\begin{figure}[H]

	\includegraphics[keepaspectratio, height=10cm]{fig/aa-hauptteil/IaC_Showcase_Structure_High-level.png}

	\caption{Infrastructure Showcase High-level Struktur}

	\centering

\end{figure}


In der Abbildung der High-Level Struktur wird auf eine detaillierte
Darstellung der Ressourcen verzichtet da je nach Plattform verschiedene
Funktionalitäten in unterschiedlichen Ressourcen zusammengefasst werden
können. Stattdessen wird durch .tf-Dateien dargestellt welche
Funktionalität in welchem Modul vorhanden sein soll und wie der Code
des Systems in Hinsicht auf Dateien aufgeteilt werden soll.

\newpage

\begin{landscape}

	\subsection{Konkreter Aufbau in Google Cloud Platform}

	\begin{figure}[H]

		\includegraphics[keepaspectratio, height=13cm]{fig/aa-hauptteil/gcp-terraform-graph-beautifier.png}

		\caption{Testsystem in Google Cloud Platform}

		\centering

	\end{figure}

\end{landscape}


Eine Auffälligkeit in Google Cloud im Vergleich mit Microsoft Azure
ist der Secret Storage der nur einmal projekt-weit existiert.
Zusätzlich war das anlegen der Container Registry nicht vollständig
ausgereift. Es existieren zwei Optionen: Die aktuelle Artifact
Registry deren Benutzung von Google empfohlen wird und die legacy
Container Registry. Die Artifact Registry war zum aktuellen Zeitpunkt
jedoch noch nicht vollständig im Terraform Provider implementiert,
es existierte keine Möglichkeit eine existierende Artifact Registry
als Data Source zu erfassen. Die Container Registry war daher die
einzige Option einen Speicherort für das Image im Vorfeld anzulegen
und in Terraform als Data Source einzubinden.\\
Weiterhin war es notwendig einen Serviceaccount anzulegen um das
Image aus der Registry zu laden und in den Nodes des Kubernetes
Clusters zu installieren.\\
Die weiteren Ressourcen konnten ohne weiteren Aufwand in einer
einfachen Weise implementiert und verwendet werden.

\newpage

\begin{landscape}
	\subsection{Konkreter Aufbau in Azure}
	\begin{figure}[H]
		
		\includegraphics[keepaspectratio, height=8cm]{fig/aa-hauptteil/azure_aufbau.png}
		
		\caption{Testsystem in Microsoft Azure}
		
		\centering
		
	\end{figure}
	
\end{landscape}

\subsection{Durchzuführende Messungen und Analysen}

\subsubsection{Functional Completeness}

Eine essentielle Voraussetzung für den Einsatz von Terraform ist die
Vollständigkeit der Funktionalitäten die für ein gegebenes
Infrastruktur-System erforderlich sind. Daher wird bei der
Implementierung des Testsystems als erstes analysiert ob alle
erforderlichen Ressourcen und Funktionalitäten in einer nutzbaren
Form vorhanden sind.

Betrachtet werden sollen die folgenden Ressourcen und
Funktionalitäten:


\begin{itemize}

	\item Anlegen virtueller Maschinen mit dem Betriebssystem Ubuntu 20.04.

	\item Anlegen eines PostgreSQL-Datenbankservers

	\item Anlegen mehrerer Datenbanken mit Charset UTF-8

	und Collation English\_United States.1252

	\item Anlegen eines Secret Storage

	\item Anlegen eines Kubernetes Cluster

	\item Erfassen einer Container Image Registry als Data Source

\end{itemize}


Zu beachten gilt dass das Referenzsystem in Microsoft Azure
implementiert ist weshalb alle Funktionalitäten dort entsprechend
garantiert sind.


\subsubsection{Time behaviour}


Eine weiterer kritischer Aspekt ist das das zeitliche Verhalten
von Terraform in Verbindung mit dem Terraform Provider und der
Cloud Plattform. Besonders in der Entwicklungsphase eines
Infrastruktur-Systems wird dieses oft ab- und wiederaufgebaut,
daher ist der zeitliche Aufwand der dafür benötigt wird von großer
Bedeutung.


Untersucht werden soll das zeitliche Verhalten der aufgelisteten
Systeme:


\begin{itemize}

	\item Das gesamte Versuchssystems

	\item Virtuelle Maschine mit dem Betriebssystem Ubuntu 20.04.

	\item PostgreSQL-Datenbankserver

	\item Kubernetes Cluster mit default Node Pool

\end{itemize}


Es werden sowohl die Dauer für den Auf- als auch Abbau gemessen.
Jeder Test wird drei mal wiederholt und der Mittelwert der
gemessenen Werte bewertet. Die Messungen werden nur durchgeführt
sofern die Plattform den Status der betroffenen Dienste als Normal/OK
führt. 


\subsubsection{Recoverability}


Für diesen Test wird zunächst der Aufbau des Systems angestoßen
durch das gewohnte \texttt{terraform apply} angestoßen. Nach 
Ablauf von ca. der Hälfte der zum vollständigen Aufbau benötigten
Zeit wird die Internetverbindung im Betriebssystem manuell
unterbrochen.\\
Im Anschluss an diese Unterbrechung wird \textit{terraform apply}
erneut ausgeführt und überprüft ob die Ressourcen anschließend
zur Verfügung stehen. Sollte dies fehlschlagen wird der aufgetretene
Fehler dokumentiert.


Folgende Szenarien werden untersucht:


\begin{itemize}

	\item Virtuelle Maschine.

	\item PostgreSQL-Datenbankserver

	\item Datenbank unter Standardeinstellungen

	\item Kubernetes Cluster mit default Node Pool

\end{itemize}


\subsubsection{Modifiability}


Hier wird untersucht wie unterschiedliche Ressourcen auf eine
Modifikation reagieren. Mithilfe der jeweiligen Browserbasierten
GUI der Cloud Plattformen wird der Effekt beobachtet und dokumentiert.


Folgende Szenarien werden untersucht:


\begin{itemize}

	\item Änderung des Betriebssystems einer Virtuellen Maschine

	\item Vergrößerung der Festplatte einer Virtuellen Maschine

	\item Veränderung des Machine-Typs einer Virtuellen Maschine

	\item Vergrößerung eines Node Pools von ein auf zwei Nodes

\end{itemize}

\chapter{Ergebnisse und Bewertung}

\section[Evaluierung der Einheitlichkeit]{Evaluierung der Einheitlichkeit der Testsysteme für Azure und Google Cloud Platform}

Terraform bietet ein einheitliches Tooling und eine einheitliche Bedienung für alle von Terraform unterstützten Plattformen. Die Arbeitsprozesse und der generelle Workflow werden dadurch relativ Plattform-unabhängig, Verbesserungen in den Arbeitsabläufen können universell in allen Terraform-Projekten umgesetzt werden.\\
Beim Schreiben des Codes, der eigentlichen Kerntätigkeit, endet die Einheitlichkeit jedoch zum größten Teil. Der Aufbau und die Bezeichnungen aller Ressourcen hängen ausschließlich von der Implementierung des Terraform Providers und damit von der Plattform ab, die Gemeinsamkeiten liegen primär in Semantik und Syntax welche durch die Sprache bestimmt werden.\\
Eine Möglichkeit zur Vereinheitlichung wird durch die Verwendung von Modulen eröffnet: Werden die Interfaces von funktional deckungsgleichen Modulen verschiedener Plattformen einheitlich über die Verwendung identischer Input-Variablen definiert.

Die wichtigste Erkenntnis ist diese: Um verschiedene Cloud Plattformen in Kombination mit Terraform einsetzen zu können ist es weiterhin erforderlich im Umgang mit der jeweiligen Plattform geschult zu sein. Das Beherrschen von Terraform kann das Wissen über individuelle Plattformen in keiner Weise ersetzen, Terraform-Kompetenzen dienen primär dazu die Umsetzung von Infrastructure as Code zu ermöglichen.

\begin{landscape}
	\section{Evaluierung der Functional Completeness}
	\begin{table}[H]
		\begin{tabular}{@{}lll@{}}
			\toprule
			& Google Cloud 
			Platform                                                            
			
			
			&
			Microsoft 
			Azure                                                               
			
			\\
			\midrule
			VM Ubuntu 
			20.04                                                               
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				\texttt{google\_compute\_instance }
				erfüllt.\end{tabular}                                               
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				\texttt{azurerm\_virtual\_machine} 
				erfüllt.\end{tabular}                                               
			\\
			\midrule
			\begin{tabular}[c]{@{}l@{}}PostgreSQL \\ 
				Datenbankserver\end{tabular}                                        
			& \begin{tabular}[c]{@{}l@{}}Funktionalität wird 
				durch Ressource \\ \texttt{google\_sql\_database\_instance} 
				erfüllt.\end{tabular}                                               
			& 
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource\\ 
				\texttt{azurem\_postgresql\_database} 
				erfüllt.\end{tabular}                                               
			\\
			\midrule
			\begin{tabular}[c]{@{}l@{}}Anlegen von Datenbanken mit\\ Charset 
				UTF-8 und Collation\\ English\_Unites States.1252\end{tabular} & 
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch die Ressource 
				\\ \texttt{google\_sql\_database} teilweise erfüllt. Collation \\ kann bei 
				Erstellung nich wie erwünscht definiert \\ werden. Default ist 
				en\_US.UTF8\end{tabular} & 
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch die \\ Ressource 
				\\ \texttt{azurem\_postgresql\_database}\\ erfüllt. Charset und Collation \\
				werden bei Erstellung definiert.\end{tabular} \\ \midrule
			Secret 
			Storage                                                             
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				\texttt{google\_secret\_manager\_secret} erfüllt.\\
			\end{tabular}                                               
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				\texttt{azurem\_key\_vault\_secret} erfüllt.\\\end{tabular}          \\ \midrule
			Kubernetes 
			Cluster                                                             
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource \\ 
				\texttt{google\_container\_cluster} 
				erfüllt-\end{tabular}                                               
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch Ressource\\ 
				\texttt{azurem\_kubernetes\_cluster} 
				erfüllt.\end{tabular}                                               
			\\
			\midrule
			\begin{tabular}[c]{@{}l@{}}Einbindung der Container\\ Registry als 
				Data Source\end{tabular}                                     & 
			\begin{tabular}[c]{@{}l@{}}Funkltionalität wird durch Data Source 
				\\ \texttt{google\_storage\_bucket} erfüllt 
			\end{tabular}                                                
			&
			\begin{tabular}[c]{@{}l@{}}Funktionalität wird durch\\Data Source\\
				\texttt{azurem\_container\_registry} erfüllt 
			\end{tabular}                                                
			\\
			\bottomrule
		\end{tabular}
	\centering
	\caption{Anaylse der Functional Completeness}
	\centering
	\end{table}
\end{landscape}

\subsubsection{Bewertung}

Die grundlegenden Computing Ressourcen werden durch beide Terraform
Provider erwartungsgemäß bereitgestellt, im Detail liegen jedoch
einige Unterschiede vor.\\
Beim Anlegen der Datenbanken in GCP können die Funktionalitäten von
Azure nicht vollständig abgebildet werden, Anpassung an Charset und
Collation sind zum Zeitpunk des Erstellens nicht möglich.
Das Charset entspricht dem gewünschten Wert, die Collation jedoch
nicht.\\
Der Secret Storage wir auf GCP einmal für ein GCP Projekt angelegt,
Azure hingegen bietet die Möglichkeit mehrere Key Vaults innerhalb
einer Resource Group anzulegen. Die Speicherung des tatsächlichen Secret
in der Ressource\\ \texttt{google\_secret\_manager\_seceret\_version} anstelle
des zuvor anzulegenden\\ \texttt{google\_secret\_manager\_seceret} fällt ´dadurch intuitiv aus.\\
Die Container Registry wird in Google Cloud in Form eines normalen
Google Storage Buckets angelegt. Die bevorzugte Methode zur Speicherung
eines Container Image in GCP stellt die Artifact Registry dar,
diese ist jedoch zum aktuellen Zeitpunkt noch nicht vollständig im
Terraform Provider implementiert. Es ist möglich eine Artifact
Registry als Terraform Ressource zu erstellen, die Einbindung einer
bereits bestehenden Artifact Registry als Data Source ist jedoch
noch nicht möglich. Der Aufwand beim Erstellen der Container Registry
über den Storage Bucket fällt höher aus als in Azure, hier wird beim
Anlegen der Container Registry die Storage-Infrastruktur automatisch
erstellt und gemanagt.

\section{Ergebnisse und Bewertung der Time Behaviour Tests}

\begin{table}[H]
	\begin{tabular}{@{}clcccc@{}}
		\toprule
		\multicolumn{1}{l}{}                                                    
		&           & 
		\multicolumn{2}{l}{Google Cloud Platform} & 
		\multicolumn{2}{l}{Microsoft Azure} \\ \midrule
		\multicolumn{1}{l}{}                                                    
		& Testlauf & 
		Aufbau               & Abbau              & Aufbau            & 
		Abbau           \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Aufbau/Abbau \\ 
				Testsystem\end{tabular}}                                 & 1         & 
		15m48s               & 7m54s              & 7m7s              & 
		6m5s            \\
		& 2         & 17m37s               & 8m11s              & 
		7m59              & 7m44s           \\
		& 3         & 15m12s               & 6m52s              & 
		6m54s             & 6m6s            \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Aufbau/Abbau\\ 
				VM\end{tabular}}                                          & 1         & 
		0m30s                & 1m3s               & 1m12s             & 
		6m5s            \\
		& 2         & 0m23s                & 1m4s               & 
		1m11s             & 1m37s           \\
		& 3         & 0m25s                & 1m4s               & 
		1m11s             & 1m40s           \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Aufbau/Abbau \\ 
				PostgreSQL-\\ Datenbankserver\end{tabular}}              & 1         & 
		3m59s                & 1m3s               & 2m28s             & 
		0m42s           \\
		& 2         & 3m58s                & 0m52s              & 
		2m32s             & 0m43s           \\
		& 3         & 3m57s                & 0m52s              & 
		2m28s             & 0m40s           \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Aufbau/Abbau\\ Kubernetes- 
				Cluster\\ mit default Node Pool\end{tabular}} & 1         & 
		3m59s                & 2m52s              & 4m36s             & 
		5m33s           \\
		& 2         & 3m39s                & 3m3s               & 
		6m5s              & 5m32s           \\
		& 3         & 3m31s                & 2m53s              & 
		5m13s             & 5m29s           \\ \bottomrule
	\end{tabular}
	\centering
	\caption{Ergebnisse der Time Behaviour Tests (1/2)}
	\centering
\end{table}

\begin{table}[H]
	\begin{tabular}{@{}clcc@{}}
		\toprule
		\multicolumn{1}{l}{}                                                    
		& Testlauf & 
		\multicolumn{1}{l}{Google Cloud Platform} & 
		\multicolumn{1}{l}{Microsoft Azure} \\ \midrule
		\multicolumn{1}{l}{\multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}Execution Plan 
					\\ für Testsystem\end{tabular}}}                & 1    & 
		1.2s                                      & 
		14.6s                               \\
		\multicolumn{1}{l}{}                                                    
		& 2    & 
		1.2s                                      & 
		15.2s                               \\
		\multicolumn{1}{l}{}                                                    
		& 3    & 
		1.6s                                      & 
		15.9s                               \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Execution Plan\\ für 
				Datenbank-\\ server\end{tabular}}                           & 1    & 
		0.9s                                      & 
		22.2s                               \\
		& 2    & 1.0s                                      & 
		23.2s                               \\
		& 3    & 1.0s                                      & 
		23.3s                               \\ \midrule
		\multirow{3}{*}{\begin{tabular}[c]{@{}c@{}}Execution Plan für\\Kubernetes 
				Cluster\\ mit default Node Pool\end{tabular}} & 1    & 
		0.8s                                      & 
		13.5s                               \\
		& 2    & 0.9s                                      & 
		13.3s                               \\
		& 3    & 0.9s                                      & 
		12.3s                               \\ \bottomrule
	\end{tabular}
\centering
\caption{Ergebnisse der Time Behaviour Tests (2/2)}
\centering
\end{table}

\subsubsection{Bewertung}


Bei der ersten Betrachtung der am Testsystem gemessenen Werte fällt
ein starker Unterschied zwischen den für den Aufbau benötigten Zeiten
des Testsystems auf, Google Cloud Platform benötigt hier beinahe die
doppelte Zeit gegenüber Azure. Bei den zusätzlichen Tests die den
Aufbau von Datenbankserver und Kubernetes Cluster analysieren liegt
der Vorteil weiterhin bei Azure, jedoch nicht ansatzweise in der selben
Ausprägung. Interessant ist ebenfalls der starke Kontrast zwischen den
Zeiten die für die Erstellung des Execution Plan benötigt werden,
hier liegen die Zeiten des Google Providers extrem unter denen des
Azure Providers.\\
Die Betrachtung der Detailunterschiede im Aufbau des Testsystems und der
individuellen Tests offenbart eine wahrscheinliche Ursache für die
stark unterschiedlichen Zeiten des Testsystems: Der jeweils zum
Einsatz kommende Maschinen-Typ.\\
Die Wahl für praktisch alle Teile des
GCP-Systems fiel auf den Typ \enquote{f1-micro}. Dieser zeichnet sich
durch besonders niedrige Kosten, aber dementsprechend auch geringe
Leistung aus. Für die initiale Phase der Infrastruktur-Entwicklung
während der noch praktisch keine Belastung der Komponenten stattfindet
kann dies eine attraktive Option darstellen.\\
Die Implementierung des Systems in Azure verwendet im Gegensatz dazu
häufig die jeweilig empfohlene Option bzw. den in der Dokumentation als
Beispiel verwendeten Typ.\\
Die individuellen Tests werden mit Maschinen-Typen durchgeführt die
eine möglichst vergleichbare Leistungsfähigkeit besitzen, konkret wurde
dabei die Anzahl der zur Verfügung stehenden CPU Cores, die Größe des
Arbeitsspeichers sowie Typ und Größe der Festplatte angepasst.\\
Die individuellen Tests offenbaren hierbei dass die Wahl des Maschinen-
und Festplattentyps nicht nur bei der Leistungsfähigkeit sondern auch
bei der für die Bereitstellung benötigten Zeit eine wichtige Rolle
spielen. Ein Testsystem das ganz oder auch nur teilweise zu Test- und
Entwicklungszwecken häufig zerstört und neu aufgebaut werden muss
könnte von der Verwendung besserer Hardware deutlich profitieren.

Eine weitere mögliche Ursache für die Zeit Differenz beim Aufbau
der Infrastruktur stellt die verwendete Availability-Region/Zone dar.
Alle Tests wurden uniform in der Zone \enquote{europe-west3-b} für
Google Cloud Platform und der Location \enquote{westeurope} für Azure
durchgeführt. Es ist in jedem Falle denkbar dass es lokale Unterschiede bei der Verfügbarkeit gibt, die verfügbaren Maschinentypen variieren zum Teil ebenfalls.


Die Unterschiede bei der Erstellung des Execution Plan werfen ebenfalls
Fragen nach den Ursachen auf. Eine mögliche Ursache
könnte in der Überprüfung zur Verfügung stehender Ressourcen
durch den Terraform Provider liegen,
eine fundierte Beantwortung dieser Frage erfordert jedoch weitere
Recherche und Tests die nicht mehr im Rahmen dieser Arbeit liegen.

\section{Ergebnisse und Bewertung der Recoverability Tests}

\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{lll}
			\hline
			& Google Cloud 
			Platform                                                            
			
			&
			Microsoft 
			Azure                                                               
			
			\\
			\hline
			\begin{tabular}[c]{@{}l@{}}Längere Unterbrechung \\ des Internets, 
				State in \\ Remote Backend\end{tabular} & 
			\begin{tabular}[c]{@{}l@{}}State korrumpiert, erneutes \\ terraform 
				apply führt zu \\ Fehler, manuelles entfernen \\ der Ressource 
				notwendig.\end{tabular} & \begin{tabular}[c]{@{}l@{}}State 
				korrumpiert, erneutes \\ terraform apply führt zu Fehler. \\ 
				Zusätzlich zur VM Ressource muss \\ die Festplatte ebenfalls 
				separat \\ manuell gelöscht werden.\end{tabular} \\ \hline
			\begin{tabular}[c]{@{}l@{}}Temporäre Unterbrechung \\ des 
				Internets, lokaler State\end{tabular}            & 
			\begin{tabular}[c]{@{}l@{}}Terraform state wird auch lokal \\ 
				korrumpiert, manuelles löschen \\ der VM-Ressource 
				notwendig.\end{tabular}                   
			&                                                                   
			
			
			\\
			\hline
			\begin{tabular}[c]{@{}l@{}}Soft Cancel von \\ Terraform 
				apply\end{tabular}                                 & State 
			korrumpiert                                                         
			
			& Shutdown sofort, state 
			korrumpiert                                                         
			
			\\
			\hline
			\begin{tabular}[c]{@{}l@{}}Hard Cancel von\\ Terraform 
				apply\end{tabular}                                  & State 
			korrumpiert                                                         
			
			& Nicht 
			durchgeführt                                                        
			
			\\
			\hline
		\end{tabular}%
	}
\centering
\caption{Ergebnisse der Recoverability Tests}
\centering
\end{table}

\subsubsection{Bewertung}


Die Tests zur Recoverability durchgeführt werden vermitteln ein relativ
gleichmäßiges Bild: Das Ergebnis jedes Szenarios ist die Korrumpierung
des Terraform State. Dementsprechend konnte die Infrastruktur durch
ein einfaches erneutes Ausführen des Execution Plan nicht erfolgreich
deployed werden und ein manuelles Löschen der bereits teilweise
konfigurierten Cloud Ressource war notwendig.


Aus diesem Ergebnis lässt sich ableiten dass keiner der Provider
zusätzliche Mechanismen zur Fehlerprävention bei beim Deployment
individueller Ressourcen implementiert. Komplexere Szenarien sollten
ein erweitertes und vollständigeres Bild bieten können, mögliche
Unterschiede könnten zum Beispiel bei Operationen die Datenspeicherung
betreffen zu Tage treten.


Der größte Unterschied der bei die Durchführung betreffend auffiel ist
die standardmäßige Timeout-Zeit für das Erstellen der Ressourcen.
Google Cloud Platform bricht das Deployment im Falle eines
Verbindungsverlusts innerhalb weniger Minuten ab, Azure wartet
in diesem Fall bedeutend länger bevor die Operation fehlschlägt.\\
Die Lösung von Google verspricht schnelleres Feedback im Fall von
Problemen, der Ansatz von Azure erlaubt es auch bei einem etwas
längeren Ausfall des Internets das aktuelle Deployment ohne weitere
manuelle Interaktion vollständig durchzuführen.

\section{Ergebnisse und Bewertung der Modifiability Tests}

\begin{table}[H]
	\begin{tabular}{@{}ccc@{}}
		\toprule
		& Google Cloud 
		Plattform                                                               
		&
		Microsoft Azure                                                        
		\\ \midrule
		\begin{tabular}[c]{@{}c@{}}Änderung des Betriebssystems \\ einer 
			virtuellen Maschine\end{tabular} & \multicolumn{2}{c}{Ressource wird 
			zerstört und neu 
			erstellt.}                                                              
		\\
		\midrule
		\begin{tabular}[c]{@{}c@{}}vergrößerung der Festplatte\\  einer 
			virtuellen Maschine\end{tabular}  & 
		\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Ressource wird zerstört 
				\\ und neu erstellt.\end{tabular}} & Führt zu 
		Error.                                                        \\ 
		\midrule
		\begin{tabular}[c]{@{}c@{}}Veränderung des Machine-Type \\ einer 
			virtuellen Maschine\end{tabular} & \multicolumn{2}{c}{Ressource wird 
			modifiziert.}                                                           
		
		\\ \midrule
		\begin{tabular}[c]{@{}c@{}}Vergrößerung des default \\ Node Pools von 1 
			auf 2 Nodes\end{tabular}  & 
		\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Ressource wird zerstört 
				\\ und neu erstellt.\end{tabular}} & 
		\begin{tabular}[c]{@{}c@{}}Ressource wird \\ modifiziert.\end{tabular} 
		\\ \bottomrule
	\end{tabular}
	\centering
	\caption{Ergebnisse der Modifiability Tests}
	\centering
\end{table}

\subsubsection{Bewertung}


Die durchgeführten Tests zum Aspekt der Modifizierbarkeit offenbaren
einige Unterschiede zwischen den getesteten Cloud Plattformen.
Die Fähigkeit von Azure einen Node Pool erweitern zu können ohne
diesen dabei neu anzulegen erlaubt es die gewünschte Änderung sehr
viel schneller durchzuführen. Die zur Modifikation des bestehenden
Node Pools benötigte Zeit entspricht etwa der Zeit des Erstellens
ohne zuvor die alte Ressource zu zerstören. Im Falle von GCP ist
dies der Fall, die alte Ressource muss zuerst vollständig zerstört
sein bevor der neue und vergrößerte Node Pool angelegt wird.


Ein schwerwiegenderes Problem auf Seiten von Azure offenbart sich
beim Erweitern der Festplattenkapazität einer VM. Während dies im Fall
von GCP über das Zerstören und neu Erstellen der Ressource möglich
ist führt dies im Falle von Azure zu einer Fehlermeldung.
Diese Fehlermeldung tritt auf da die Festplatte als eigene
Ressource angelegt wird. Die verwendete \texttt{azurerm\_virtual\_machine}
Ressource bietet zwar die Option die Festplatte gemeinsam mit der
Maschine zu löschen, in dem hier getesteten Szenario ist dies
allerdings nicht möglich. Aufgrund dessen wird eine manuelle
Interaktion notwendig um zum gewünschten Endzustand zu gelangen.